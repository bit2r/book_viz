[{"path":"index.html","id":"데이터-시각화","chapter":"데이터 시각화","heading":"데이터 시각화","text":"사단법인 한국 알(R) 사용자회는 디지털 불평등 해소와 통계 대중화를 위해\n2022년 설립되었습니다. 다양한 활동을 추진하고 있으며 특히, 오픈 통계 패키지 개발(BitStat, 빗스탯)을 비롯하여\n최근에 데이터 사이언스 교재를 제작하여 공개하고 있습니다.그 첫번째 결과물로 John Fox 교수님이 개발한 설치형 오픈 통계 패키지 Rcmdr(Fox 2016 ; Fox Bouchet-Valat 2021 ; Fox 2005)를\n신종화 님께서 한글화 및 문서화에 10년 넘게 기여해주신 한국알사용자회 저작권을 흔쾌히\n허락해 주셔서 설치형 오픈 통계 패키지 - Rcmdr로 세상에 나오게 되었습니다.두번째 활동을 여기저기 산재되어 있던 시각화 관련 자료를 묶어\n데이터 시각화(Data Visualization)를 전자책 형태로 공개하였고,\n데이터 분석 관련 저술을 이어 진행하게 되었습니다.데이터 분석 언어 R에 관한 지식을 신속히 습득하여 독자들이 갖고 있는 문제에\n접목시키고자 하시는 분은 한국 알(R) 사용자회에서 번역하여 공개한\nR 신병훈련소(Bootcamp) 과정을\n추천드립니다.“데이터 사이언스를 지탱하는 기본기” 공유하고 위해\n소프트웨어/데이터 카펜트리(Software/Data Carpentry)의\n원작내용을 번역(software-carpentry?)하고 필요한 경우 저자들의 경험을 녹인\n출판물도 준비중에 있습니다. 밝혀둡니다.데이터 시각화 저작물을 비롯한 한국 알(R) 사용자회 저작물은\n크리에이티브 커먼즈 저작자표시-비영리-동일조건 변경 허락 (-NC-SA)\n라이선스를 준용하고 있습니다.후원계좌디지털 불평등 해소를 위해 제작중인 오픈 통계패키지 개발과 고품질 콘텐츠 제작에 큰 힘이 됩니다.하나은행 448-910057-06204사단법인 한국알사용자회","code":""},{"path":"viz-motivations.html","id":"viz-motivations","chapter":"1 .  시각화","heading":"1 .  시각화","text":"컴퓨터를 기반으로 한 시각화 시스템은 시각적으로 데이터를 표현함으로서\n사람이 작업을 더욱 효율적으로 수행할 수 있도록 돕는다.시각화는 시각지능을 갖춘 인공지능을 통해 사람을 대체하는데 초점을 둔 것이라보다\n시각화를 통해 인간능력을 보조하고 증강시키는데 유용하다.따라서, 완전 자동화 해결책이 존재하고 신뢰성이 있는 경우 대안이 존재하는 경우 시각화는 필요하지 않다. 하지만, 많은 분석과 개발문제에 어떤 질문을 던져야 되는지 사전에 알고 있는 경우가 적어, 명세가 분명하지 않는 경우 시각화가 적합하다.","code":""},{"path":"viz-motivations.html","id":"viz-tamara-why","chapter":"1 .  시각화","heading":"1.1 왜 시각화가 필요한가?","text":"시각화는 최종 데이터분석 결과를 표현하는 데이터 과학 제품과 인포그래픽으로 많은 관심을 받았다. 하지만 꼭 시각화가 데이터 과학 최종 결과물로 의미가 있는 것은 아니다. 인포그래픽과 같은 최종 결과를 제작하는 과정은 수많은 시도와 실패의 결과물로 조금씩 진전을 이뤄낸 산출물이다. 이 과정에서 데이터에 대한 충분한 이해가 필요한데 원본 데이터를 눈으로 일일이 살펴보거나 요약 통계량으로 데이터가 갖고 있는 의미를 충분히 살펴보는데는 한계가 있다.\n원데이터를 첫번째 행부터 마지막행까지 첫번째 변수부터 마지막 변수까지 일일이 살펴보는 작업은 상당한 인지부하를 가져와 쉽게 피로를 유발한다. 인지부하(cognitive load)를 시각적 지각(perception)으로 해당 작업을 바꿔 수월히 업무를 수행하는데 필수적인 기법이 시각화(Visualization)라고 볼 수 있다.datasets 패키지에 포하함된 women 데이터는 이미 정렬이 되어 있어서, 신장이 커짐에 따라 체중이 증가하는 것을 알 수 있지만, 데이터만 보고 이해하려면 인지적으로 데이터 한줄을 읽고 머리속으로 생각하고, 두번째 줄을 읽고 생각하고, … 이런 과정을 반복하면서 인지적 부하가 증가하게 된다.\n하지만, 시각적으로 표현하게 되면 한눈에 신장과 체중 관계를 볼 수 있다.women 데이터셋이 몸무게는 파운드(lbs), 신장(inch)로 되어 있어 우리나라에서 사용하는\nkg, cm 단위로 시각화에 앞서 변환시킨다.","code":"\nlibrary(tidyverse)\nlibrary(kableExtra)\n\ndatasets::women %>% \n  kableExtra::kbl() %>% \n  kableExtra::kable_styling()\nwomen %>% \n  mutate(height = 2.54 * height,\n         weight = 0.45 * weight) %>% \n  ggplot(aes(y=weight, x=height)) + \n    geom_smooth(color='pink') +\n    geom_point(color='blue', size=2) +\n    labs(x = \"신장\",\n         y = \"몸무게\",\n         title = \"신장과 몸무게 관계\")"},{"path":"viz-motivations.html","id":"viz-anscombe","chapter":"1 .  시각화","heading":"1.2 Anscombe 4종류 데이터","text":"Anscombe(Anscombe 1973)는 1973년 “Anscombe’s Quartet”로 알려진 동일한 통계량을 갖는 4종류 데이터셋을 만들어서 시각화의 중요성을 공개했다. 4종류의 데이터는 모두 동일한 평균, 분산,\n상관계수와 회귀식을 갖는다. 두 변수 x, y에 대한 통계량에 대한 정보는 다음과 같다.","code":""},{"path":"viz-motivations.html","id":"viz-anscombe-descriptive","chapter":"1 .  시각화","heading":"1.2.1 데이터셋 기술통계량","text":"datasets 패키지 내부에 anscombe 명칭으로 데이터셋이 포함되어 있어 앞서 제기한\n기술통계량이 맞는지 평균, 분산, 상관계수, 회귀식 회귀계수를 통해 소수점 아래 일부 차이가 있지만 동일하다는 것을 확인할 수 있다.","code":""},{"path":"viz-motivations.html","id":"viz-anscombe-viz","chapter":"1 .  시각화","heading":"1.2.2 데이터셋 시각화","text":"anscombe 데이터셋 기술 통계량을 통해 4종류 데이터셋이 동일한 분도를 갖고 있고\n표본추출로 보면 모집단에서 잘 추출된 표본이라고 볼수도 있으나 시각화를 통해 보면\n전혀 다른 특성을 갖는 데이터라는 것을 한번에 알 수 있다. 즉, 가장 일반적으로\n첫번째 데이터셋과 같은 특성이 기술통계량을 통해 존재한다는 것이 일반적이다.\n하지만, 2차식이 내재된 두 변수의 관계(두번째 데이터셋)일 수도 있으며,\n강한 선형 관계가 두변수 사이 존재하지만 튀는 관측점이 하나 존재하는 관계(세번째 데이터셋)일 수도\n있으며 네번째 데이터세의 경우 데이터 입력과정에서 오류가 의심되는 경우(네번째 데이터셋)일 수도 있다.","code":"\n# https://rpubs.com/debosruti007/anscombeQuartet 코드를 일부 변형하여 시각화 사용\np1 <- ggplot(anscombe) + geom_point(aes(x1, y1), color = \"darkorange\", size = 3) + theme_bw() + scale_x_continuous(breaks = seq(4, 20, 2)) + scale_y_continuous(breaks = seq(0, 12, 2)) + geom_abline(intercept = 3, slope = 0.5, color = \"cornflowerblue\") + expand_limits(x = 4, y = 4) + labs(title = \"첫번째 데이터셋\")\np2 <- ggplot(anscombe) + geom_point(aes(x2, y2), color = \"darkorange\", size = 3) + theme_bw() + scale_x_continuous(breaks = seq(4, 20, 2)) + scale_y_continuous(breaks = seq(0, 12, 2)) + geom_abline(intercept = 3, slope = 0.5, color = \"cornflowerblue\") + expand_limits(x = 4, y = 4) + labs(title = \"두번째 데이터셋\")\np3 <- ggplot(anscombe) + geom_point(aes(x3, y3), color = \"darkorange\", size = 3) + theme_bw() + scale_x_continuous(breaks = seq(4, 20, 2)) + scale_y_continuous(breaks = seq(0, 12, 2)) + geom_abline(intercept = 3, slope = 0.5, color = \"cornflowerblue\") + expand_limits(x = 4, y = 4) + labs(title = \"세번째 데이터셋\")\np4 <- ggplot(anscombe) + geom_point(aes(x4, y4), color = \"darkorange\", size = 3) + theme_bw() + scale_x_continuous(breaks = seq(4, 20, 2)) + scale_y_continuous(breaks = seq(0, 12, 2)) + geom_abline(intercept = 3, slope = 0.5, color = \"cornflowerblue\") + expand_limits(x = 4, y = 4) + labs(title = \"네번째 데이터셋\")\n\ngridExtra::grid.arrange(p1, p2, p3, p4, ncol=2, top = \"앤스컴 콰르텟(Anscombe's Quartet)\")"},{"path":"viz-motivations.html","id":"viz-framework","chapter":"1 .  시각화","heading":"1.3 시각화 얼개","text":"오랜동안 시각화를 연구한 타마라 먼즈너(Tamara Munzner) 교수는 시각화를 위한 얼개(framework)로\n다음 4가지 영약으로 나눠 공학적 접근을 취할 것을 제안하고 있다.(Munzner 2014)\n타마라 교수가 제안한 시각화 분석 얼개는 4가지 부분으로 구성된다.전문영역 : 최종 사용자 고객이 누군인가?추상화\n전문영역의 구체적인 점을 시각화 용어로 번역\n데이터 추상화 : 시각화하는 것이 무엇()인가?\n작업 추상화 : 왜() 사용자가 눈을 돌리는가?\n\n전문영역의 구체적인 점을 시각화 용어로 번역\n데이터 추상화 : 시각화하는 것이 무엇()인가?\n작업 추상화 : 왜() 사용자가 눈을 돌리는가?\n데이터 추상화 : 시각화하는 것이 무엇()인가?작업 추상화 : 왜() 사용자가 눈을 돌리는가?표현양식(idiom)\n데이터가 어떻게() 시각화되는가?\n시각적 인코딩 표현양식 : 시각화하는 방법\n상호작용 표현양식 : 조작하는 방법\n\n데이터가 어떻게() 시각화되는가?\n시각적 인코딩 표현양식 : 시각화하는 방법\n상호작용 표현양식 : 조작하는 방법\n시각적 인코딩 표현양식 : 시각화하는 방법상호작용 표현양식 : 조작하는 방법알고리즘\n효율적 연산방법\n효율적 연산방법시각화 얼개시각화 시스템 실행시간, 메모리 사용량 등을 측정하고, 연산 복잡성을 분석하는 알고리즘 작업은 컴퓨터 과학자의 몫이다.\n여러가지 대안 시스템 아키텍처를 정당화하고 시각적 인코딩 방법과 상호작용하는 표현양식을 설계하는 것은 시스템 설계자의 몫이다.\n시각화 시스템 결과물을 정량적으로 분석하고, 사용자 인간에 대한 실험을 추진하는 것은 인지심리학자의 몫이다.\n이를 감싸고 있는 데이터 추상화와 작업추상화가 있는데, 시스템 설계자가 앞단에서 설계하면 후행단에서 인지심리학자가 검증하고, 컴퓨터 과학자가 개발하는 구조를 갖는다.이 모든 시작은 전문영역에서 문제점을 인식하고 기존의 도구를 사용하는 목표 사용자를 관측하는 것에서 시작되는데 이는 인류학자, 민족지라는 분야와 연관된다.\n따라서, 기술중심으로 밖으로 퍼져나갈 수도 있지만, 문제해결작업으로 시각화를 활용하는 것도 가능한 접근법이다.","code":""},{"path":"viz-motivations.html","id":"viz-R-system","chapter":"1 .  시각화","heading":"1.4 R 시각화 시스템","text":"동일한 시각화 산출물을 제작한다고 하더라도 철학에 따라 차이점이 있다.\n크게 시각화 도구는 명령형과 선언형으로 나눠지고 그래프 문법을 따르는\nggplot의 경우 선언형에 해당된다.명령형(imperative): “방법()”에 초점, Processing, OpenGL, prefuse선언형(declarative): “무엇()”에 초점, D3, ggplot2, ProtovisR은 역사가 오래된 검증된 언어라 보니 그 시대의 컴퓨팅 환경과\n축적된 지적자산이 반영되어 다양한 시각화 시스템이 존재한다.\n가장 대표적으로 3가지 시각화 시스템을 이해하면 실무적으로 충분하다.Base 시각화 시스템lattice 시각화 시스템: Cleveland의 Trellis Graphics에서 출발ggplot 시각화 시스템: Wilkinson의 Grammar Graphics에서 출발2017년 3월 기준 R 팩키지를 시각화 시스템으로 구분하면 다음과 같다.\n현재는 ggplot이 후발주자의 잇점을 발휘하여 대세로 자리잡았고\n이는 ggplot2 패키지 기여자수, 코드 길이, 연관된 패키지수를 확인하면\n쉽게 파악할 수 있다.","code":""},{"path":"viz-motivations.html","id":"viz-base-system","chapter":"1 .  시각화","heading":"1.4.1 Base 시각화 시스템","text":"R설치하면 내장된 Base 시각화 시스템은 화가의 팔레트(Artist Palallete) 모형으로 빈 도화지 캔바스 위에 화가가 그림을 그리는 것과 동일한 방식으로 시각화 산출물을 만들어 나간다.\nplot() 혹은 유사한 시각화 함수로 시작해서 텍스트(text), 선(line), 점(point), 축(axis) 등을 표현하는데 주석(Annotation) 함수를 활용한다.따라서, 사람이 사고하는 방식으로 시각화 산출물을 만들어 나가 편리하지만, 시각화 산출물을 다시 그리려고 하면 처음부터 다시 해야 되기 때문에 시각화 산출물을\n만드는 초기부터 시간을 갖고 잘 설계해 나가야 된다. 그리고, 시각화 산출물이 생성되면 다른 것으로 변환하기 어려운 단점이 있고, 그래픽 언어가 아니라 일련의 R 명령어\n묶음에 불가하다.","code":""},{"path":"viz-motivations.html","id":"viz-lattice-system","chapter":"1 .  시각화","heading":"1.4.2 lattice 시각화 시스템","text":"lattice 시각화 시스템은 lattice 팩키지를 통해 설치되고, 함수 호출(xyplot(), bwplot() 등)을 통해 시각화 산출물을 생성하게 된다.\n조건에 따라 일변량 혹은 다변량 변수를 시각화하는데 유용하다. 즉, 특정 범주형 변수 수준에 따라 두 변수간의 관계를 시각적으로 표현하는 것을 예로 들 수 있다.\n전체 시각화 산출물 결과는 여백(margin), 공간 등은 자동으로 한번에 정해져서, 화면에 다수 시각화 산출물을 배치할 때 유용하다.하지만, 함수호출 한번으로 전체 시각화 산출물을 명세하는 것이 쉽지는 않다. 특히 주석(Annotation)을 시각화 산출물에 다는 것이 그다지 직관적이는 않다.\n그리고 lattice 함수를 통해 시각화 산출물이 만들어지면 더이상 추가는 불가하다.키보드 자판으로 통계모형을 R로 표현하는 방법처럼 변수들을 lattice 시각화 시스템에서\n공식으로 표현할 수 있다는 점은 큰 장점중 하나다.","code":""},{"path":"viz-motivations.html","id":"viz-ggplot-system","chapter":"1 .  시각화","heading":"1.4.3 ggplot 시각화 시스템","text":"ggplot 시각화 시스템은 ggplot2 팩키지를 통해 설치가 가능하다. Base 시각화 시스템과 lattice 시각화 시스템의 장점을 취사선택해서 개발된 것으로 보는 견해도 있다.\n그래픽 문법(Grammer Graphic)에 기반하고 있으며, lattice 시각화 시스템처럼 공백, 텍스트, 제목 등을 자동으로 설정하고,\nBase 시각화 시스템에서 지원하는 다양한 그래픽 요소를 추가하는 것도 가능하다. 전반적으로 lattice느낌이 나지만 사용하기는 직관적이며 다양한 그래픽 요소를\n추가하는 것도 쉽다. 물론 ggplot에서 자동으로 설정하는 것도 원하는 설정으로 바꾸는 것도 가능하다.","code":""},{"path":"viz-motivations.html","id":"viz-grid","chapter":"1 .  시각화","heading":"1.4.4 grid 시각화 시스템","text":"grid 시각화 시스템은 lattice와 ggplot의 기반이 되는 시각화 시스템으로 R 버전 1.8.0 부터 Base 팩키지의 일부가 되었다.1\ngrid_0.7-4에서 Base 팩키지 일부가 되어 버젼이 Base 팩키지에 맞춰 버젼이 급상승했다.grid 시각화 시스템을 사용해서 위와 동일하게 상기 그래프를 그리면 다음과 같다.\ngrid 시스템을 숙달하기까지 시간이 걸리지만, 익숙해지면 장점이 상당하다.","code":""},{"path":"hello-world.html","id":"hello-world","chapter":"2 .  헬로우 월드","heading":"2 .  헬로우 월드","text":"","code":""},{"path":"hello-world.html","id":"napoleon-invasion","chapter":"2 .  헬로우 월드","heading":"2.1 나폴레옹 러시아 침공","text":"나폴레옹 황제가 프랑스를 통치할 때 1812년 최대 전성기를 구가했다.최대 전성기를 구가하던 1812년 나폴레옹은 러시아 침공을 감행했다. 나폴레옹의\n러시아침공은 데이터 시각화의 역작을 남기는 계기가 되기도 했다.\n미나르는 프랑스의 러시아 침공을 군더더기 없이 시작부터 폐퇴하여 돌아온 과정까지 간략하게 표현했다.미나르 데이터 시각화의 지명을 자세히 보면 프랑스의 러시아 침공에 대해 대략적으로\n인식하고 있는 것과 다소 차이가 난다. 통상 프랑스 수도 파리에서 나폴레옹 대군이\n출발하여 러시아 모스코바에서 한동안 머물다가 다시 수도 파리로 돌아와서 황제에서\n끌어내려져 엘바섬으로 위배를 떠난 것으로 알려져 있지만 실제 미나르가 데이터에\n기반하여 제작한 시각화 그래프에는 진실이 담겨있다. 2","code":""},{"path":"hello-world.html","id":"napoleon-viz","chapter":"2 .  헬로우 월드","heading":"2.2 시각화","text":"","code":""},{"path":"hello-world.html","id":"references","chapter":"2 .  헬로우 월드","heading":"2.3 참고서적","text":"영어로 참고할 오픈 데이터 시각화 교재(Healy 2018)(Dougherty Ilyankou 2021)(Wilke 2019)","code":""},{"path":"happy-viz.html","id":"happy-viz","chapter":"3 .  행복한 시각화","heading":"3 .  행복한 시각화","text":"캐나다 브리티쉬 콜럼비아 대학 STAT545 교육과정이 공개되어\n초창기 데이터 과학이 정립될 때 큰 역할을 하였다.\n“행복한 시각화 생활을 위한 비밀” 장에 성공적인 시각화를 핵심적인 내용이 담겨있다.시각화 그래프를 제작하는데 어려움이 있다면,\nggplot2 코드에 문제가 있다고 시각화 관련 부분에 집중적인 시간을 투여할 것이다.\n하지만 다음 세가지 지점을 먼저 살펴봐라.데이터프레임에 시각화 관련 작업을 담아둔다.데이터프레임을 깔끔하게(tidy) 제작한다; 시각화에 적절한 자료형으로 변환범주형(factor) 변수를 적절히 활용함은 물론 범주형 자료 장인이 된다.나중에 심도있게 다룰 시각화 자료구조인 깔끔한 데이터(Tidy Data)를 제작하게 되면\n그동안 자신을 괴롭혔던 시각화 관련 문제는 자연히 사라져 버린다.\n이를 위해서 dplyr 패키지의 데이터 다루는 여러 동사를 tidyr 패키지\n깔끔한 데이터 제작 동사와 결합하여 사용하게 되면 생산성을 크게 높일 수 있다.","code":""},{"path":"happy-viz.html","id":"viz-secret-dataframe","chapter":"3 .  행복한 시각화","heading":"3.1 시각화 입력 자료구조: 데이터프레임","text":"기억해야 할 단 한가지 사항은 시각화 자료구조는 데이터프레임이다.\n좀더 구체적으로 깔끔한 데이터다.\n시각화 산출물을이 동일하다고 하더라도 작성한 코드를 면밀히 살펴보면\n가독성이 떨어짐은 물론 tidyverse 관습과 동떨어진 경우를 종종 보게 된다.예를 들어, 많은 경우 변수가 데이터프레임 밖에 복사되어\n작업공간에 독립된 객체로 존재시켜 이를 시각화하는 것이다.앞선 방식의 문제는 ggplot2 패키지로 시각화가 되지 않고 오류가 발생된다.\n근본 원인은 ggplot2 패키지 ggplot() 함수가 입력값이 데이터프레임이라는데 있다.\n즉, 데이터프레임을 입력받아 시각화 그래프를 출력으로 뱉어내는데 이를 충족시키지 못할 경우\n의도한 바가 컴퓨터에 전달되지 않아 오류가 나와 더이상 진전을 이룰 수가 없다.즉, 변수를 데이터프레임에 담아 보관하고 ggplot() 함수에 시각화 대상 데이터프레임에 전달하면 된다.\n이런 전략은 R에 존재하는 다른 시각화 플랫폼에도 동일하게 적용된다.\nR에는 ggplot을 비롯하여 Base 그래픽, lattice 그래픽 등 크게 3가지가 존재한다.\n모두 방식에는 다소 차이가 있지만 근본적으로 데이터프레임을 입력받아 시각화 그래프를 출력으로 내보낸다.파이프 연산자를 사용해서 좀더 직관적으로 코드를 다음과 같이 제작하게 되면\n의미가 명확해질 것이다.예를 들어 시각화 대상이 국가별, 대륙별, 년도별 데이터를 필터링하는 경우도 있다.\n관련 모든 변수가 데이터프레임에 있게되면 훨씬 더 쉽고 안전하게 작업을 수행할 수 있다.\n앞서 시각화 변수를 별도 작업공간(메모리)에 별도 저장하여 관리할 경우 대비하여\n생각하게 되면 데이터프레임에 시각화 모든 정보를 담아두는 전략의 명확한 우위가 드러난다.ggplot2 시각화 시스템만 데이터프레임을 받아 시각화하는 유일한 특이한 사례는 아니다.\n데이터프레임에 모든 정보를 담아두고 필요한 경우 dplyr 동사로 변수생성, 필터링,\n그룹별 요약, 정렬 등 데이터 조작 작업을 통해 시각화 대상 데이터프레임을 만들고\n이를 시각화하는 전략은 널리 인정되는 모범사례다.데이터프레임을 data= 선택옵션으로 전달하는 것이 많이 사용되는 R 함수에 일반적인 기능이다.\n예를 들어, lm(), aggregate(), plot(), t.test().\n따라서, 이런 방식이 기본디폴트 작업방식이 된다.","code":"\nlibrary(gapminder)\nlife_exp <- gapminder$lifeExp\nyear <- gapminder$year\nlibrary(ggplot2)\nggplot(aes(x = year, y = life_exp)) + \n  geom_jitter()\nlibrary(tidyverse)\ngapminder %>% \n  ggplot(aes(x = year, y = life_exp)) + \n  geom_jitter()"},{"path":"happy-viz.html","id":"viz-secret-explicit-dataframe","chapter":"3 .  행복한 시각화","heading":"3.2 dplyr::data_frame() 자료구조","text":"데이터는 이미 있는데 데이터프레임이 아니라면,\n“왜 데이터프레임이 아닌가?” 라고 본인에게 질문을 던진다.\n시각화 대상 변수는 생성했는가?\n필요한 변수를 먼저 데이터프레임에 반영해 둬야 할 것이다.\ndplyr 팩키지에 data_frame() 신규 함수는 내장된 data.frame() 함수에 대한 개선된 버젼이다.\n데이터프레임을 시각화 자료구조로 채택하게 되면\n다른 변수를 정의할 수 있고, 강제변환으로 인한 데이터 훼손도 방지할 수 있다.\n구체적으로 말하면, 문자열은 명시적으로 지정하지 않게 되면 요인으로 변환되지 않는다.\n이것만으로도 데이터프레임과 연관된 문제를 회피할 수 있다.데이터프레임에 변수를 새로 추가하는 dplyr::mutate() 함수를 통해, 동일한 길이를 갖는\n연관된 변수를 처리할 자동으로 데이터프레임 내부에서 처리하여 반영한다.","code":"\nlibrary(tidyverse)\nmy_dat <- data_frame(x = 1:5,\n             y = x ^ 2,\n             text = c(\"alpha\", \"beta\", \"gamma\", \"delta\", \"epsilon\"))\n\nglimpse(my_dat)## Rows: 5\n## Columns: 3\n## $ x    <int> 1, 2, 3, 4, 5\n## $ y    <dbl> 1, 4, 9, 16, 25\n## $ text <chr> \"alpha\", \"beta\", \"gamma\", \"delta\", \"epsilon\"\nggplot(my_dat, aes(x, y)) + \n  geom_line() + \n  geom_text(aes(label = text), vjust = 1.5) +\n  geom_point(size = 2)"},{"path":"happy-viz.html","id":"viz-secret-with","chapter":"3 .  행복한 시각화","heading":"3.3 다른 접근방식 with()","text":"데이터프레임을 시각화 입력으로 삼는 전략의 우수성을 기존 다른 접근법과 비교해보자.\n슬프게도 모든 함수가 data= 인자를 제공하지는 않는다.\n상관계수를 계산하는 cor() 함수를 예로 들어보자. 다음 코드는 동작하지 않는다:물론 다음과 같이 데이터프레임 명칭을 항상 반복하면 원하는 결과를 얻을 수 있다.하지만, gapminder를 두번 타이핑하게 되어 중복 반복 작업이 있어\n사람들이 싫어한다. 아마도 이렇게 gapminder를 반복적으로 타이핑한다는 의식속에 숨겨진 공포가\n작업공간에 독립된 객체에 변수를 복사하게 만든 동기가 되지 않았나 싶다.() 함수가 이런 문제를 피해나가는 해결책이 된다.\n데이터프레임을 첫번째 인자로 넣는다.\n두번째 인자는 특별히 격리된 환경에서 평가되는 표현식이 된다.\n명령어 한줄 혹은 여러줄로 된 토막 코드가 될 수도 있다.\n특별한 점은 데이터프레임에 변수를 이름으로 참조할 수 있다는 것이다.magrittr 팩키지를 사용하게 되면, 또다른 선택욥션이 %$% 연산자를 사용해서 데이터프레임 내부 변수를 노출시켜 향후 연산작업을 진행해 나가는 방식도 있다. 참고로 magrittr 패키지의 영감을 얻어\ntiydverse 생태계를 연결하는 %>% 이 생겨났다.","code":"\ncor(year, lifeExp, data = gapminder)\n# Error in cor(year, lifeExp, data = gapminder) : \n#  unused argument (data = gapminder)\ncor(gapminder$year, gapminder$lifeExp)## [1] 0.436\nwith(gapminder,\n     cor(year, lifeExp))## [1] 0.436\nlibrary(magrittr)\ngapminder %$%\n  cor(year, lifeExp)## [1] 0.436"},{"path":"happy-viz.html","id":"viz-secret-case-study","chapter":"3 .  행복한 시각화","heading":"3.4 사례","text":"특정한 국가 예를 들어 한국을 뽑아 연도별로 모든 정량적 변수를 도식화한다.본능적으로 먼저 gapminder 데이터에서 한국을 뽑아 변수별로 루프를 돌려서\n개별적으로 그림을 그리고 이를 한데 묶는다.\n사실 이러한 방식으로도 작업을 수행할 수 있다.\n하지만, 데이터 형태를 바꾸는 방식이 루프를 돌리는 것보다 현재 R 생태계를 고려하면 좀더 “R스럽다”.","code":""},{"path":"happy-viz.html","id":"viz-secret-case-study-data","chapter":"3 .  행복한 시각화","heading":"3.4.1 데이터 형태 바꾸기","text":"먼저 gapminder 데이터에서 한국만 뽑아낸다.\n그리고 나서 pop, lifeExp, gdpPercap 변수를 var 동반변수를 키로\nvalue 변수를 값으로 하여 변수하나로 gather()함수를 통해 모은다.필터링된 korea_dat는 12 행을 갖는다.\nkorea_tidy 데이터프레임에 변수를 세개 모아 쌓아서, 행의 갯수가 3 배 되는 것이 이해된다.\n즉, 폭이 넓은 데이터를 길이가 긴 데이터로 바꿔서 36 행을 갖는다.","code":"\nkorea_dat <- gapminder %>%\n  filter(country == \"Korea, Rep.\")\n\nkorea_tidy <- korea_dat %>%\n  pivot_longer(cols = c(pop, lifeExp, gdpPercap), names_to = \"변수\", values_to = \"값\")\n\ndim(korea_dat)## [1] 12  6\ndim(korea_tidy)## [1] 36  5"},{"path":"happy-viz.html","id":"viz-secret-case-study-facet","chapter":"3 .  행복한 시각화","heading":"3.4.2 facet 기능으로 변수를 반복","text":"데이터가 깔끔한 데이터프레임에 반복을 돌릴 수 있는 변수를 나타내는 적절한 요인으로 구성되어서,\nfacet 기능을 구현하기만 하면 된다.","code":"\np <- korea_tidy %>% \n  ggplot( aes(x = year, y = 값) ) +\n    facet_wrap(~ 변수, scales=\"free_y\") \n\np + geom_point() + geom_line() +\n  scale_x_continuous(breaks = seq(1950, 2011, 15))"},{"path":"happy-viz.html","id":"viz-secret-summary","chapter":"3 .  행복한 시각화","heading":"3.4.3 요약","text":"한국을 뽑아 시각화한 코드가 다음에 요약되어 있다.앞에서 언급한 규칙에서 나온 이득을 상기 토막 코드가 보여주고 있다.한국만 dplyr 패키지 filter() 함수 데이터 조작을 통해 시각화 데이터프레임으로 독립.데이터를 폭넓은(wide) → 긴(long) 형태로 바꾼 전형적인 깔끔화 사례.\n칼럼 세개를 칼럼 한개로 모으는데 이유는 그림에 y-축에 각 변수를 도식화에 용이.\n칼럼 세개를 칼럼 한개로 모으는데 이유는 그림에 y-축에 각 변수를 도식화에 용이.각 작은 그림(facet)에 속한 관측점을 구별하는데 범주(변수)을 사용하고 나서, 패싯 기능 적용.","code":"\ngapminder %>%\n  ## 데이터프레임 데이터 조작: `dplyr`\n  filter(country == \"Korea, Rep.\") %>%\n  ## 시각화를 위한 깔끔한 데이터: `tidyr`\n  pivot_longer(cols = c(pop, lifeExp, gdpPercap), names_to = \"변수\", values_to = \"값\") %>% \n  ## 그래프 문법에 따른 시각화: `ggplot`\n  ggplot(aes(x = year, y = 값)) +\n    facet_wrap(~ 변수, scales=\"free_y\") +\n    geom_point() + \n    geom_line() +\n    scale_x_continuous(breaks = seq(1950, 2011, 15))"},{"path":"시각화-구성요소.html","id":"시각화-구성요소","chapter":"시각화 구성요소","heading":"시각화 구성요소","text":"데이터 시각화를 할 때 다양한 구성요소를 이해하고 이를 체계적으로 조합하여\n시각화 객체를 제작해야만 이후 재사용가능한 시각화 산출물을 제작하여 지속적인\n발전을 이뤄낼 수 있다.","code":""},{"path":"viz-font.html","id":"viz-font","chapter":"4 .  글꼴","heading":"4 .  글꼴","text":"R을 단순히 통계 언어로 생각하지 말고 적용범위를 확대해서 활용하면\n데이터 과학 산출물을 다양한 전자문서로 제작하여 커뮤니케이션 할 수 있다.\nPDF, HTML, 워드 등 문서 뿐만 아니라, 파워포인트 같은 발표자료를\n슬라이드로 제작하여 배포할 수 있다. 그래프 문법(Grammar Graphics)에 따라\nggplot 시각화를 산출물에도 다양한 글꼴(font)을 반영하여 좀더 관심을 끌 수 있는\n그래프 제작도 가능하다. 데이터 과학자나 개발자 관점에서도 통합개발환경(IDE)이\n필요한데 개발과 저작에 집중할 수 있는 글꼴을 지정하여 활용할 경우\n생산성도 높일 수 있고 좀더 쾌적한 환경에서 개발을 진행할 수 있다.R 스크립트 작성을 위한 글꼴과 그래프에 한글 글꼴(font)을 적용한다.\nggplot을 비롯한 시각화를 위해 extrafont와 showtext 패키지를\n활용하여 적절한 한글 글꼴을 사용할 뿐만 아니라 코딩 개발할 때\nR 스크립트(.R) 및 R마크다운(.Rmd)에서도 적절한 한글글꼴 사용을 위해서\n코딩관련 글꼴도 설치한다.기본적인 작업흐름은 운영체제에 먼저 외부에서 가져온 폰트를 설치한다.\n그리고 나서 extrafont 팩키지 font_import() 함수를 사용해서 폰트를\nR에서 불러 사용할 수 있도록 설치한다. 그리고 나서 loadfonts() 함수를\n사용해서 글꼴을 ggplot등에서 불러 사용한다.\n구글 글꼴을 사용하고자 할 경우 showtext 패키지를\n사용해서 로컬 컴퓨터에 설치하여 적용한다.R 폰트/글꼴 설치","code":""},{"path":"viz-font.html","id":"font-coding","chapter":"4 .  글꼴","heading":"4.1 R 코딩 글꼴","text":"문서를 위해 작성하는데 사용되는 글꼴과 R 코딩을 위해 사용되는 글꼴은\n차이가 난다. 왜냐하면 R 코딩에 사용되는 글꼴은 가독성이 좋아야하고\n디버깅에 용이해야 된다. 영어는 consolas 글꼴을 많이 사용하는데 무료가\n아니다. 그래서 consolas에서 영감을 받은 SIL 오픈 폰트 라이선스를\n따르는 Inconsolata가 R\n코딩에 많이 사용되고 있다. 하지만, R코드를 작성할 때 주석을 한글로\n달거나 R마크다운 작업을 할 경우 유사한 기능을 하는 한글 글꼴이 필요하다.네이버 나눔고딕 코딩글꼴D2 Coding 글꼴“네이버 나눔고딕 코딩글꼴”과 “D2 Coding 글꼴”을 설치하고 나서 RStudio\nIDE에서 “Tools” → “Global Options…”를 클릭하면 “Options”창에서\nAppearance에서 Editor font:에서 설치한 코딩전용 글꼴을 선택하고\nEditor theme:도 지정한다.D2 코딩폰트 설치","code":""},{"path":"viz-font.html","id":"r-viz-font","chapter":"4 .  글꼴","heading":"4.2 ggplot 시각화 글꼴","text":"extrafont 팩키지에서 font_import() 함수로 운영체제(윈도우/리눅스)에\n설치된 글꼴을 R로 가져온다. 그리고 나서 loadfonts() 함수를 사용해서\n설치된 글꼴을 사용하는 작업흐름을 따르게 된다.","code":"library(extrafont)\nfont_import(pattern = \"D2\")\n\nImporting fonts may take a few minutes, depending on the number of fonts and the speed of the system.\nContinue? [y/n] y\nScanning ttf files in C:\\Windows\\Fonts ...\nExtracting .afm files from .ttf files...\nC:\\Windows\\Fonts\\D2Coding-Ver1.3.2-20180524.ttf => C:/Users/tidyverse_user/Documents/R/win-library/3.5/extrafontdb/metrics/D2Coding-Ver1.3.2-20180524\nC:\\Windows\\Fonts\\D2CodingBold-Ver1.3.2-20180524.ttf => C:/Users/tidyverse_user/Documents/R/win-library/3.5/extrafontdb/metrics/D2CodingBold-Ver1.3.2-20180524\nC:\\Windows\\Fonts\\MOD20.TTF => C:/Users/tidyverse_user/Documents/R/win-library/3.5/extrafontdb/metrics/MOD20\nFound FontName for 3 fonts.\nScanning afm files in C:/Users/tidyverse_user/Documents/R/win-library/3.5/extrafontdb/metrics\nWriting font table in C:/Users/tidyverse_user/Documents/R/win-library/3.5/extrafontdb/fontmap/fonttable.csv\nWriting Fontmap to C:/Users/tidyverse_user/Documents/R/win-library/3.5/extrafontdb/fontmap/Fontmap...\n\nfont_import(pattern = \"Nanum\")"},{"path":"viz-font.html","id":"font-viz-font-example","chapter":"4 .  글꼴","heading":"4.2.1 ggplot 한글 글꼴 사례","text":"extrafont 패키지 loadfonts() 함수를 사용해서 ggplot에서 적용시킬 수 있는\n글꼴을 불러냈다. R 내장 데이터셋 iris를 사용하여 나눔글꼴 “Nanum Pen Script”을 기본 글꼴로 적용시켰다.","code":"\nlibrary(tidyverse)\nlibrary(extrafont)\nloadfonts() # 로컬 PC 에서 설치된 글꼴을 불러냄!!!\n\niris %>% \n  ggplot(aes(x=Sepal.Length, y=Petal.Length, color=Species)) +\n    geom_point()+\n    labs(title=\"붓꽃 데이터 한글 글꼴 적용\", color=\"붓꽃 종류\") +\n    theme_minimal(base_family = \"Nanum Pen Script\") +\n    theme(legend.position = \"top\")"},{"path":"viz-font.html","id":"font-showtext","chapter":"4 .  글꼴","heading":"4.3 showtext 패키지 3","text":"extrafont 패키지를 통해 한자를\n포함한 한글을 처리할 수 있었으나, extrafont는 트루타입폰트(.ttf)를\nPDF 그래픽 장치에 초점을 맞춰 개발이 되었다. 따라서, 데이터과학\n최종산출물이 PDF 형태 책이 아닌 경우 여러가지 면에서 다양한 한글 글꼴을\n표현하는데 있어 한계가 있다.새로 개발된 showtext\n팩키지는 Ghostscript같은 외부 소프트웨어를 활용하지 않고도 다양한\n(그래픽) 글꼴을 지원한다. showtext로\nR 그래프를 생성할 때, 다양한 글꼴(TrueType, OpenType, Type 1, web fonts\n등)을 지원한다.과거 PDF와 같은 책형태로 정보를 공유하고 전달하는 방식이 주류를 이뤘다면\n인터넷 등장 이후 웹으로 정보 생성과 소비가 주류로 떠오르게 되면서 글꼴에도\n변화가 생겼다. 가까운 미래에는 웹을 우선시하는 글꼴이 대세를 이룰 것으로 보인다.showtext 글꼴사용자가 그래프에 텍스트를 넣기 위해 R 함수에서 text()를 호출할 때\nshowtext가 활성화 되어 있으면 showtext 팩키지 text() 함수를\n호출해서 그래픽 혹은 이미지 파일에 텍스트를 표현하고 그렇지 않는 경우는\n디폴트 장치함수 text() 함수를 호출하게 되어 있다.내부적으로 상세 작동 로직은 글꼴 위치를 파악해서 글리프(glyph) 정보를\n추출하고 비트맵 형식, 벡터그래픽 형식에 따라서 비트맵일 경우 raster()\n장치함수를 호출하고, 벡터그래픽인 경우 path() 장치함수를 호출해서\n기능을 수행한다.","code":""},{"path":"viz-font.html","id":"showtext-korean-example","chapter":"4 .  글꼴","heading":"4.3.1 R 설치 글꼴 확인","text":"extrafont 팩키지 loadfonts() 함수를 통해 .ttf 파일 정보를\n확인한다. 현재 구글 글끌 페이지에서 많은 한글\n글꼴을 지원하지 않고 있다. 구글에서 전세계 글꼴을 지원하다보 동아시아 3국 대상으로\n지원되는 글꼴은 적은 것으로 보인다.","code":"\n# 0. 환경설정 --------------------------------------------------------------------------\nlibrary(tidyverse)\nlibrary(showtext) # 글꼴, install.packages(\"showtext\")\nlibrary(extrafont)\nloadfonts()"},{"path":"viz-font.html","id":"font-showtext-korean-example-ggplot","chapter":"4 .  글꼴","heading":"4.3.2 ggplot 글꼴 적용","text":"한글 글꼴을 바로 적용하기에 앞서 showtext 패키지 포함된 영문글꼴 적용 사례를 먼저 돌려보자.\nggplot 그래픽에 적용되는 showtext 활용 기본 작업흐름은 다음과 같다.글꼴을 적재한다.그래픽 장치를 연다showtext를 통해 텍스트를 표시한다고 지정한다.그래프를 그린다.장치를 닫는다.","code":"\nlibrary(tidyverse)\nlibrary(showtext)\n\n# ggplot 그래픽 ----------------------------\n\ndat <- data.frame(cond = factor(rep(c(\"A\",\"B\"), each=200)), \n                  rating = c(rnorm(200),rnorm(200, mean=.8)))\n\nfont_add_google(\"Schoolbell\", \"bell\") # 글꼴 적재\n\nshowtext.begin() # 그래픽 장치 열기\n\nggplot(dat, aes(x=rating)) + \n  geom_histogram(binwidth=.5)+ \n　annotate(\"text\", 1, 2.1, family = \"bell\", size = 15, color=\"red\", label = \"histogram\")\n\nshowtext.end() # 그래픽 장치 닫기"},{"path":"viz-font.html","id":"font-showtext-korean-example-ttf","chapter":"4 .  글꼴","heading":"4.4 로컬 글꼴 적용","text":"로컬 컴퓨터에 저장된 .ttf 파일을 사용자 지정해서 가져온 후 이를\nggplot에 반영하여 한글을 R 그래프에 적용하는 것도 가능하다.\nshowtext는 extrafont 보다 나중에 개발되어 extrafont가\n로컬 컴퓨터에 설치된 글꼴을 ggplot에 구현되는데 전력을 다했다면\nshowtext는 이를 발판으로 나중에 개발되어 구글 폰트와 같은\n인터넷 글꼴과 최근 웹출판에 대한 개념도 넣어 개발된 것이 차이점이다.","code":"\n# ３. 한글 그래픽 --------------------------------------------------------------------------\n## 나눔펜　스크립트\nfont_add(\"NanumBarunGothic\", \"NanumBarunGothic.ttf\")\n\nshowtext.auto()\n\np <- ggplot(NULL, aes(x = 1, y = 1)) + ylim(0.8, 1.2) +\n  theme(axis.title = element_blank(), axis.ticks = element_blank(),\n        axis.text = element_blank()) +\n  annotate(\"text\", 1, 1.1, family = \"NanumBarunGothic\", size = 15, color=\"red\",\n           label = \"한글 사랑\") +\n  annotate(\"text\", 1, 0.9, label = 'korean for \"Hello, world!\"',\n           family = \"NanumBarunGothic\", size = 12)\n\nprint(p)"},{"path":"viz-color.html","id":"viz-color","chapter":"5 .  색상","heading":"5 .  색상","text":"","code":""},{"path":"viz-color.html","id":"color-mechanism","chapter":"5 .  색상","heading":"5.1 시각화 메커니즘 4","text":"크게 보면 기계 즉, 컴퓨터가 색을 이해하고 표현하는 RGB 체계와 사람이 색을 인지하고 이해하는 HCL 체계로 나누어 진다. 2진수로 표현된 시각적 데이터는 RGB 16진수로 변환되어 모니터에 표시되고,\n물리적 광자(photon)로 사람눈에 위치한 망막에 꽂히게 되고,\n사람은 뇌에서 인지한 후에 이를 처리하여 시각적인 정보를 인식하게 된다.따라서, 사람뇌에 인식할 수 있는 시각적인 정보로 데이터를 구성해야만 다양한 종류의 모니터를 통해\n효율적이고 효과적으로 정보가 전달될 수 있다.시각적 인지 메커니즘","code":""},{"path":"viz-color.html","id":"color-dataviz-mechanism-rgb","chapter":"5 .  색상","heading":"5.1.1 16진수 RGB 표색법","text":"양수 숫자나 크레파스 명칭 대신에, 일반적이고 컴퓨터가 읽어들일 수 있는 색상 표색법이 16진수 팔레트다.\nCynthia Brewer 는 펜실베니아 대학에서 교수로 색상이론과 시각화에 관련된 전문분야를 갖고 있으며 특히,\nColorBrewer 으로 알려진 색생체계는 웹, 출판, 색맹을 고려하여 널리 쓰이고 있다.\nColorBrewer 색상체계를 R에서 시각화를 할 때 사용될 수 있게 만든 것이 RColorBrewer 패키지다.\nRColorBrewer Dark2 팔레트를 통해 실제로 구현된 색상체계를 살펴보자.# 기호는 관례로 붙이는 것이고, 16진수 문자열을 다음과 같이 파싱한다:\n#rrggbb에서 rr, gg, bb 각각은 적색, 녹색, 청색 채널에 대한 생상농도를 나타낸다.\n각 색상은 2를 밑으로 하는 16개 숫자를 나타내고, “16진수(hexadecimal)” 혹은 줄여서 헥스(hex)로 부른다.\n다음에 밑을 10으로 하는 십진수와 16진수 비교표가 다음에 나와 있다.예를 들어, 팔렛트 첫 색상이 #1B9E77으로 명세되어 있다. 따라서, 녹색 채널 색상농도는 9E가 된다.\\[ 9E = 9 * 16^1 + 14 * 16^0 = 9 * 16 + 14 = 158 \\]무슨 뜻일까? 해당 채널의 가장 낮은 값은 00=0 이 되고,\n가장 높은 값은 FF=255 가 된다.도움이 되는 기억해야될 중요한 사례가 다음에 나타나 있다.\n적색, 녹색, 청색에 대한 강렬한 RGB 색상은 다음과 같다.다음에 흑백, 회색을 표현한 것이 나타나 있다.“gray” 회색으로 치환하게 되면, “gray”를 보게되는 어느 곳에서나 동일한 결과를 얻게 됨에 주목한다.\n모든 채널을 최대값으로 하면 흰색, 모든 채널을 최소값으로 하면 검정색이 된다.R에서 색상을 지정하는 방법양의 정수: palette()함수로 조작하거나 검색한 현재 색상 팔레트에 인덱스를 사용.색상 명칭: colors() 함수로 검색된 색상16진수 문자열: 16진수로 구성된 3개조에 추가해서, 알파 투명도를 나타내는 네번째 채널을 넣어 16진수 4개조로 구성된 생상표로 확장하기도 한다.rgb(), col2rgb(), convertColor() 함수도 유용하니, 자세한 내용은 도움말을 참조한다.","code":"\nlibrary(RColorBrewer)\nbrewer.pal(n = 8, name = \"Dark2\")## [1] \"#1B9E77\" \"#D95F02\" \"#7570B3\" \"#E7298A\" \"#66A61E\" \"#E6AB02\" \"#A6761D\"\n## [8] \"#666666\""},{"path":"viz-color.html","id":"dataviz-mechanism-hcl","chapter":"5 .  색상","heading":"5.2 RGB 색상모형 대안 - HCL","text":"RGB 색공간과 색상모형이 유일무이하고 가장 최고는 아니다.\n컴퓨터 화면에 색상을 표현하는데는 자연스럽지만, 일부 영역에서 색상을 선택하는\n작업에는 이런 모형을 적용하기 어렵다.\n예를 들어, 사람이 구별하기는 쉽지만, 인지적으로 색상별로 비교되는 생각으로 구성된\n정성적인 팔레트를 만들어 내는 방법은 명확하지 않다.\n컴퓨터에 사용되는 색상을 기술하는데 RGB를 사용하지만,\n사람이 색상체계를 구축하는 색공간에 RGB체계를 사용할 이유는 없다.\n이점은 사람과 컴퓨터가 다른 것이고, 이를 인정해야만 된다.색상모형은 일반적으로 RGB와 마찬가지로 세가지 차원으로 구성된다.\n이는 망막에 세가지 다른 수용체를 인간이 갖는 생리적 사실에 기인한다.\nRGB와 인간 시각 체계에 대한 자세한 정보는 블로그를\n참고한다.\n색상모형의 차원이 사람이 인식할 수 있는 식별가능한 정보량에 더 가까이 부합되면 될수록, 더욱 유용하다.\n이런 부합성이 사려깊게 작성된 팔레트 생성을 가능하게 하고, 더불어 특정한 특성을 갖는 색공간에 대한 길을 연다.\nRGB 색체계는 인간의 인식체계와 일치성이 떨어진다.\n적색, 녹색, 청색광을 탐지할 수 있는 광수용체를 갖기 때문에,\n색을 인지하는 체험이 RGB 방식으로 분해된다는 것을 의미하지 않는다.\n적색과 녹색을 섞은 것으로 황색을 인식하는 체험을 했는가?\n물론 아니다. 생리학적인 현실은 그렇다.\n또다른 RGB 대안 모형이 HSV(Hue-Saturation-Value, 색상-채도-명도)모형이다.\n불행하게도, 색을 선택하는데 문제가 많은데, 이유는 색상이 서로 중첩되는 차원을 갖기 때문이다.사람이 인지하기 좋은 색모형은 무엇일까? CIELUV 와 CIELAB 이 가장 잘 알려진 사례다.\nCIELUV의 변종인 HCL(Hue-Chroma-Luminance, 색상-채도-휘도) 모형을 좀더 살펴보자.\nZeileis와 동료들이 R 사용자를 위한 팩키지로 멋지게 작성했다.5\ncolorspace R 팩키지에 딸려있고, HCL 색상모형을 탐색하고 이용하는데 도움을 준다.\n마지막으로, HCL 색모형이 ggplot2에 RColorBrewer와 마찬가지로 잘 녹여져있다.HCL 색상모형의 세가지 차원색상(Hue) : 색상은 일반적으로 “색상이 뭐지?”라고 생각할 때 생각나는 것이다. 이해가 바로되는 쉬운 것이다! 각도로 주어지고 따라서 0 에서 360 까지 값을 갖는데, 무지개 도넛을 상상하면 된다.채도(Chroma) : 채도는 색상이 얼마나 순수한지 혹은 생생한지 나타낸다. 특정 색상이 회색과 섞일 수록, 채도는 떨어진다. 가장 낮은 값은 0 으로 회색 그자체에 대응되고, 최대값은 휘도에 따라 변한다.휘도(Lumiance) : 휘도는 명도(brightness), 명도(Lightness), 광도(intensity), 명도(value)와 관련된다. 낮은 휘도는 어두움을 의미하고, 진짜 검정색은 휘도가 0 이다. 높은 휘도는 밝음을 의미하고, 진짜 흰색은 휘도가 1 이다.저자는 채도와 휘도를 이해하고 구별하는데 힘든 시간을 보냈다. 위에서 살펴봤듯이, 색체계는 서로 독립된 것이 아니고, 3차원 HCL 공간에 기이한 모형으로 정보를 제공하고 있다.위캠의 ggplot2 책에 나온 6.6 그림이 HCL 색공간을 이해하는데 도움이 된다.ggplot2 HCL 색공간위캠 책에 언급된 내용을 다시 적으면 다음과 같다: 각 측면, 창은 휘도에 따라 가장 낮은 값에서 높은 값 순으로 HCL 공간을 슬라이스로 나누어 도식화한 것을 보여주고 있다. 0 과 100 극단 휘도값은 생략되었는데, 이유는 각각 검은 점과 흰점으로 나타나기 때문이다.\n슬라이스 내부에, 중심은 채도가 0 으로, 회색에 대응된다. 슬라이스 끝쪽으로 이동하면,\n채도가 증가하고, 색상이 더 순색에 가까워지고 농도가 짖어진다. 색상은 각도로 매핑된다.colorspace 팩키지에 가치있는 기여는 아마도 함수를 사용해서 색상공간을 합리적 방식으로 색공간을 이리저리 돌아다닐 수 있게 만든 것이다.\n이와는 대조적으로 RColorBrewer 팩키지가 제공하는 팔레트는 정교하게 제작되었지만, 불행히도 고정이다.인지기반 색상체계를 사용하는 것에 대한 옹호 사례와 더불어 색공간에 0 이 자리하는 것을 알려주는 중요성을 시연하고 있다.“Engineers Scientists Worried Color?”","code":""},{"path":"viz-color.html","id":"viz-printer-cmyk","chapter":"5 .  색상","heading":"5.3 프린터 색상모형: CMYK 6 7","text":"CMYK 색상표는 시안(Cyan), 마젠타(Magenta), 옐로(Yellow), 블랙(Black = Key)를 원색으로 하여 명도가 낮아지는 감산혼합으로 주로 출력물 인쇄 혹은 사진 필림 현상에 사용되며 쿼크익스프레스, 일러스트레이터, 포토샵 등에서 CMYK 감산혼합을 지원한다. 현실적인 문제 때문에 RGB나 HSB(HSV)보다 표현 가능한 색이 적은 것으로 알려져 있다.학창시절 감산혼합의 색의 3원색은 빨강, 노랑, 파랑인데, CMYK는 생뚱맞게도 시안(Cyan), 마젠타(Magenta), 옐로(Yellow), 블랙(Black = Key)을 원색으로 하는데 이유는 빨강은 사실 자홍색(마젠타), 파랑은 청록색(시안)이라 정확한 색상이 후자가 맞다. 우리가 잘못 배운 탓이 크다.RGB 생상과 CMYK 생상을 PDF 파일로 찍어 상호 비교해보자. 8RGB 색상 출력CMYK 색상 출력","code":""},{"path":"viz-color.html","id":"dataviz-color-brewer-viridis","chapter":"5 .  색상","heading":"5.4 RColorBrewer 와 viridis","text":"","code":""},{"path":"viz-color.html","id":"dataviz-color-brewer","chapter":"5 .  색상","heading":"5.4.1 RColorBrewer","text":"색상선택이 가장 논란이 많고, 이리저리 만지작 거리면서 정말 많은 시간을 보내는 분야다.\n지리학자이며 생상 전문가 Cynthia Brewer 교수가 출판과 웹에서 사용되는 색상표를 제작했고, 이는 RColorBrewer\n팩키지에 반영되어 있다. 팩키지를 설치하고 사용하면 된다. 연관된 전체 팔레트를 살펴보는 명령어는 display.brewer.() 이다.팔레트는 종류가 많지만 다음 세가지 범주에 속한다. 위에서 아래부터 다음과 같다.순차적(sequential) : 낮은 것에서 높은 것으로 한쪽 극단이 흥미롭고 반대쪽 극단이 재미없는 것을 시각화하는데 매우 좋다.\n예를 들어 p-값, 상관계수 (주의: 상관계수 1 이 흥미로운 것은 양수를 가정했다)정량적(quantitative) : 순서가 없는 범주형 자료를 시각화할 때 유용하다. 예를 들어, 국가나 대륙.\n특수한 “쌍을 이룬” 팔레트가 있다; 예를 들어, 곡물 밀 유형같이 실험이 아닌 요인, 실험군과 대조군 같은 이진 실험 요인.발산하는(diverging) : 극단의 음수에서 극단의 양수까지 범위를 같는 것을 시각화하는데 유용한다.\n이런 데이터는 극단의 값이 중간에 위치한 덜 흥미로운 지점을 지난다. 예를 들어, t-통계량, z-점수, 상관계수가 이에 속한다.명칭을 명세해서 RColorBrewer 팔렛트 하나만 볼 수 있다.","code":"\ndisplay.brewer.pal(n = 8, name = 'Dark2')"},{"path":"viz-color.html","id":"dataviz-viridis","chapter":"5 .  색상","heading":"5.4.2 viridis","text":"2015년 Stéfan van der Walt 와 Nathaniel Smith는 파이썬 matplotlib 팩키지에 사용될\n새로운 색상 지도를 설계했고, SciPy 2015에서 발표했다.\nviridis 팩키지로 인해 R에 4가지 신규 팔레트가 추가되었다. CRAN과,\nGitHub에서 팩키지를 만날 수 있다.viridis 색상표는 완벽하게 균등하게 지각되도록 설계되었고, 정규형식에서나 흑백으로 전환되었을 때도 마찬가지다. 또한 색망을 갖는 독자도 올바르게 지각될 수 있도록 설계되었다.아직 나온지 얼마되지 않아서, 자세한 사항은 viridis 팩키지를 설치하고 소품문을\n읽고 직접 경험하기 바란다.","code":""},{"path":"viz-color.html","id":"dataviz-viridis-blind","chapter":"5 .  색상","heading":"5.4.3 색맹을 갖는 사람","text":"dichromat 팩키지(CRAN)는\n2색시자에 대한 효과적인 색상조합을 선택하는데 도움이 된다.colorschems 목록에는 17 가지 색상조합이 담겨있는데, 적색과 녹색을 구별하는 능력이 없거나 예외적인 시력을 갖는 2색시자에게 적합하다.dichmat() 함수는 색상을 변환해서 다른 형태의 색맹에 근사적인 효과를 구현할 수 있어서,\n후보 색상조합에 대한 효과를 평가할 수 있게 한다.\ndata(\"dalton\") 명령어는 256 색상 팔레트를 표현하는 객체를 생성하는데,\n정상 시야로 표현되는 것과, 적록(red-green) 색맹과 청녹(green-blue) 생맹으로 표현되는 것이다.(Rogowitz Treinish 1996)","code":"\nlibrary(dichromat) # install.packages(\"dichromat\")"},{"path":"ggplot-component.html","id":"ggplot-component","chapter":"6 .  구성요소","heading":"6 .  구성요소","text":"깔끔한 데이터(tidy data)가 준비되면 이를 시각화하기 위해서는 데이터를 시각화 객체에 매핑하게 되는 메커니즘이 필요하다.\n주요 구성요소로 시각적 매핑(Aesthetics), 척도(Scale), 좌표계(Coordiate System), 축(Axis) 등이 필요하다.","code":""},{"path":"ggplot-component.html","id":"ggplot-aesthetics","chapter":"6 .  구성요소","heading":"6.1 시각적 매핑(Aesthetics)","text":"ggplot에서 시각적 매핑(Aesthetics)는 aes() 내에 시각적으로 표현되는 모든 것을 담고 있다.\n시각화 대상은 크게 두가지로 나눠지는데 연속형과 범주형이다. 온도나 몸무게 같은 경우는 특정 두 데이터 값 사이 연속된 값이 있지만,\n수학에서 정수와 같이 표현되는 쪼갤 수 없는 경우는 국가를 생각하면 한국과 미국 사이 존재하는 값이 없다.\n시각화를 할 경우 위치(position), 모양(shape), 크기(size), 색상(color), 선굵기(line width), 선유형(line type)을 사용하여 좌표계(coordinate system), 척도(scale)와 결합하여 최종 시각화 결과물을 제작된다. Claus Wilke 시각화 책에 언급된 다양한 시각적 매핑을 통해 효과적으로 데이터의 정보를 표현할 수 있다.(Wilke 2019) 당연히 위치, 모양, 크기, 색상, 선굵기, 선유형 중 어떤 것을 사용하느냐에 따라 시각화로 전달되는 정보의 양은 달라진다. 예를 들어, 위치는 시각적 변별력이 선 유형보다 크다.\n그림 6.1: 위치, 모양, 크기, 색상, 선굵기, 선유형 등 시각적 매핑\n","code":""},{"path":"ggplot-component.html","id":"scale-mapping","chapter":"6 .  구성요소","heading":"6.2 척도 매핑","text":"데이터가 주어지면 시각적 객체(모양, 색상, 크기 등)와 매핑을 해야 되는데 그 둘 사이를 연결하는 것이 척도(Scale)이다.\nx축과, y축 척도에 시각적 객체를 매핑해야 비로서 데이터 값을 그래프로 표현된다.\n척도에 위치가 지정되면 시각적 매핑 객체를 다양하게 표현할 수 있다. 만약 위치가 척도에 모호하게 표현되게 되면\n시각적 객체가 제대로 그래프에 표현되는데 문제가 된다.\n그림 6.2: 시각적 객체 척도 매핑\n","code":""},{"path":"ggplot-component.html","id":"coordinate","chapter":"6 .  구성요소","heading":"6.3 좌표계","text":"데이터 시각화에서 앞서 데이터를 척도와 시각적 객체로 준비를 했다면 이를 최종 그래프로 제작하기 위해서는 좌표계가 필요하다.\n네이버 사전에서 좌표계는 공간상의 한 점의 위치를 표시하는 숫자들의 순서쌍인 좌표를 정하기 위한 체계로서, 원점과 기준 길이, 기준 축이나 기준선들의 집합을 통틀어 이르는 말이다. 가장 널리 사용되는 좌표계는 데카르트 직각좌표계와 극좌표계가 널리 사용된다.\n다음은 mtcars 데이터 차량 기통수를 막대그래프와 원그래프를 사용하여 동일한 내용을 좌표계만 달리하여 시각적으로 표현해따.\n그림 6.3: 직교좌표계와 극좌표계\n","code":""},{"path":"ggplot-component.html","id":"coordinate","chapter":"6 .  구성요소","heading":"6.4 축(axis)","text":"데이터 값을 선형 척도에 매핑하여 시각화하는 것이 일반적이지만 x, y 축이\n대표적으로 날짜와 같은 시계열 데이터인 경우 혹은 시분초를 나타내는 경우도 있어 이에 맞춰\n적절히 축을 맞춰야 한다. 덧셈이 아니라 곱셈에 대해 선형인 경우 로그변환을 취하여\n데이터 본연의 척도를 반영하도록 축을 조정한다. 많이 사용되는 로그 변환의 경우\n밑을 10으로 하는 상용로그와 자연로그가 있어 명확히 축라벨에 적시하여 혼동을 피하는 것이 좋다.\n로그 변환시 0이 있는 경우 문제가 되기 때문에 sqrt() 변환도 로그변환이 갖는 표현법의 장점을\n갖추면서도 로그변환 시 생기는 번거러움을 해소하기 자주 사용된다.\n그림 6.4: 선형, 로그, 제곱근 축\n","code":""},{"path":"시각화-전용-데이터.html","id":"시각화-전용-데이터","chapter":"시각화 전용 데이터","heading":"시각화 전용 데이터","text":"","code":""},{"path":"tidy-data.html","id":"tidy-data","chapter":"7 .  깔끔한 데이터 개념","heading":"7 .  깔끔한 데이터 개념","text":"톨스토이 장편소설 “안나 카레니나”에 나오는 유명한 문구로 행복한 가정 원칙이 있다.“행복한 가정은 모두 비슷한 이유로 행복하지만 불행한 가정은 저마다의 이유로 불행하다.”\n(“Все счастливые семьи похожи друг на друга, каждая несчастливая семья несчастлива по-своему”,\nHappy families alike, every unhappy family unhappy way.)유발 하라리도 이를 차용하여 “세상에 실패한 국가의 유형도 각기 저마다의 이유로 다르지만, 성공한 국가는 비슷한 이유를 갖는다”라고 주장했고, 해들리 위컴(Hadley Wickham)도 “Like families, tidy datasets alike every messy dataset messy way.” Tidy Data에 대한 정의를 내리면서 동일한 주장을 했다.","code":""},{"path":"tidy-data.html","id":"tidy-data","chapter":"7 .  깔끔한 데이터 개념","heading":"7.1 데이터 깔끔화","text":"시각화를 하기 전에 데이터를 깔끔하게 해야하는 이유는 근본적으로 사람이 보는 데이터와 기계가 처리하는\n데이터의 형태가 다르기 때문이다. 즉, 사람이 보기 좋은 데이터는 기계가 처리하기 어렵고,\n기계가 처리하기 좋은 형태는 사람이 보고 이해하는데 어려움이 있다.\n따라서, 시각화를 위한 깔끔한 데이터(Tidy datasets)가 준비되면, 데이터를 조작하고, 모형화하고, 시각화는 물론이고\n커뮤니케이션도 용이하다.깔끔한 데이터 원칙은 코드(Codd) 박사의 관계대수(relational algebra) 와 깊은 관련이 있지만,\n통계학 전공자에게 친숙한 언어로 표현하여 데이터를 다루는 실무에 익숙한 통계학자와 데이터 분석가에 적합하다.깔끔한 데이터는 특정한 구조를 갖추고 있는데 변수 는 열(column)이고, 관측점 은 행(row)이며,\n행과 열이 교차하는 셀(Cell)은 값(Value)이 위치하게 되고\n관측단위에 대한 형태 는 테이블(table)로 구성된다. (Wickham 2014)해당 데이터셋에 관측점과 변수를 식별하는 것이 쉽게 생각되지만,\n일반적으로 변수와 관측점을 정확하게 정의하는 것이 놀랍게도 어렵다.\n행과 행보다는 변수간 기능적 관계(functional relationship)를 기술하는 것이 더 쉽기 때문에\n칼럼 그룹집단 비교보다 관측점 그룹집단 사이 비교를 하는 것이 더 쉽다.\n최근에 rowwise() 연산자가 도입되어 필요한 경우 행으로 데이터 작업하는 것도 수월해졌다.","code":""},{"path":"tidy-data.html","id":"tidy-data-setup","chapter":"7 .  깔끔한 데이터 개념","heading":"7.2 깔끔한 데이터","text":"깔끔한 데이터는 데이터셋의 의미를 구조에 매칭하는 표준적인 방식이다.\n행, 열, 테이블이 관측점, 변수, 형식에 매칭되는 방식에 따라\n데이터셋이 깔끔하거나 깔끔하지 않은 것으로 나뉜다.깔끔한 데이터(tidy data) 는 결국 데이터 분석을 쉽게 할 수 있는 데이터로 볼 수 있다.각 변수가 칼럼이 된다.각 관측점은 행이 된다.각 셀은 값이 된다.관측 단위에 대한 형태가 테이블을 구성한다.데이터셋(Dataset)데이터셋은 정량적이면 숫자형, 정성적이면 문자열로 저장되는 값(value) 의 집합이다.\n모든 값은 변수(variable) 와 관측점(observation) 에 속하게 된다.\n변수에 모든 값은 동일한 속성을 측정하게 되고 (예를 들어, 키, 온도, 기간 등),\n관측점은 속성마다 동일한 단위로 측정되는 값이 담겨진다 (예를 들어, 사람, 종족, 날짜).깔끔한 데이터가 의미가 있으려면 깔끔한 데이터가 입력으로 들어가서 깔끔한 데이터가 입력으로 나와야만 된다.(깔끔한) 데이터 입력 → 함수 f(x) → (깔끔한) 데이터 출력Tidy-input → 함수 f(x) → Tidy-output","code":""},{"path":"tidy-data.html","id":"messy-data-definition","chapter":"7 .  깔끔한 데이터 개념","heading":"7.3 엉망진창 데이터","text":"깔끔하지 않는 데이터(messy data) 는 앞서 언급한 깔끔한 데이터와 다른 형태 데이터를 지칭한다.\n컴퓨터 과학에서 말하는 코드 제3 정규형이지만, 해들리 위컴이 통계적 언어로 다시 표현한 것이다.\n또한, 깔끔한 데이터는 R같은 벡터화 프로그래밍 언어에 특히 잘 맞는다.\n왜냐하면 동일한 관측점에 대한 서로 다른 변수 값이 항상 짝으로 매칭되는 것을 보장하기 때문이다.변수와 관측점의 순서가 분석에 영향을 끼치는 것은 아니지만,\n순서를 잘 맞춰 놓으면 값을 스캔해서 검색하는 것이 용이하다.\n고정된 변수(fixed variable)가 실험계획법에 기술되고 나서 측정된 값이 뒤에 나오는 것처럼\n변수와 값에 대한 순위를 잘 맞춰 정리해 놓게 되면 장점이 많다.깔끔한 데이터를 사실 이해하기는 쉽지 않다. 하지만 엉망진창인 데이터(Messy Data)를\n보게 되면 상대적으로 깔끔한 데이터(Tidy Data)에 대한 이해를 높일 수 있다.\n깔끔하지 않은 데이터의 대표적인 문제점을 다음과 같이 5가지로 유형화시켜 정리할 수 있다.칼럼 헤더에 변수명이 아닌 값이 온다.변수 다수가 한 칼럼에 저장되어 있다.변수가 행과 열에 모두 저장되어 있다.관측 단위에 대한 다양한 형태가 동일한 테이블에 저장되어 있다.한가지 관측 단위가 테이블 다수에 흩어져 저장되어 있다.깔끔한 데이터가 아닌 보통 데이터깔끔하게 처리한 데이터 ","code":""},{"path":"tidy-data.html","id":"tidy-data-case-study","chapter":"7 .  깔끔한 데이터 개념","heading":"7.4 깔끔한 데이터 사례","text":"깔끔하지 못한 데이터로 지목(?)된 퓨리서치 원데이터는 Pew Research Center Religion & Public Life 웹사이트에서\n2015년 다운로드 받았고, GitHub에\n데이터가 공유되어 있다.깔끔하지 않은 messy 상태 데이터를 깔끔한 tidy 상태 데이터로 변환시킨 사례를\n통해 실전 감각을 익혀보자.깔끔하기 전 데이터깔끔하게 만든 후 데이터사실 깔끔하게 정리된 데이터는 사람이 보기에 적합하지는 않다. 오히려 엉망진창인\n퓨리서치 원데이터가 사람이 이해하고 보기에는 더 편하다.","code":""},{"path":"tidy-data.html","id":"make-tidy-data-code","chapter":"7 .  깔끔한 데이터 개념","heading":"7.5 깔끔한 데이터 제작 코드","text":"다운로드 받은 pew.sav 파일을 데이터프레임으로 만든 후 범주형 자료분석을 위해서 요인형(factor) 변수로 수준을 정리한 후 count 함수를 빈도수를 산출한다.사람이 보기 편한 형태 wide 표형태 데이터는 다음과 같이 나타낼 수 있다. 과거 spread() 동사를 사용했다면 직관적인 함수인 pivot_wider()를 사용하는 것이 좋다. 인자도 names_from=, values_from= 을 사용해서 머릿속에 담긴 내용이 코드에 직관적으로 담기도록 코딩한다.","code":""},{"path":"ggplot-datasets.html","id":"ggplot-datasets","chapter":"8 .  준비된 데이터","heading":"8 .  준비된 데이터","text":"시각화 작업을 할 때 가장 문제되는 것 중 하나가 원천데이터다. 데이터가 깔끔하게\n준비되어 있으면 시각화 업무에 집중하여 놀라운 성과물을 낼 수 있다. 반면에 데이터가\n엉망진창인 경우 시각화 범위도 축소되고 시각화 각 단계를 건널 때마다\n문제를 해결해 가면서 시각화 작업을 수행하게 되어 노력대비 기대한 산출물을 얻을\n가능성은 낮아진다.데이터 사이언스와 시각화의 예제 데이터로 가장 많이 추천되는 것이\n갭마인더(gapminder)와 팔머펭귄(palmerpenguins) 데이터셋이다.\n두 데이터셋 모두 CRAN에 등록된 공식 데이터 패키지다.","code":""},{"path":"ggplot-datasets.html","id":"palmer-penguins","chapter":"8 .  준비된 데이터","heading":"8.1 팔머 펭귄","text":"미국에서 “George Floyd”가 경찰에 의해 살해되면서 촉발된 “Black Lives Matter” 운동은 아프리카계 미국인을 향한 폭력과 제도적 인종주의에 반대하는 사회운동이다.데이터 과학에서도 최근 R.. Fisher의 과거 저술한 “genetical theory natural selection” (Fisher 1958) 우생학(Eugenics) 대한 관점이 논란이 되면서 R 데이터 과학의 첫 데이터셋으로 붓꽃 iris 데이터를 다른 데이터, 즉 펭귄 데이터로 대체하는 움직임이 활발히 전개되고 있다. palmerpenguins 데이터셋이 대안으로 많은 호응을 얻고 있다.","code":""},{"path":"ggplot-datasets.html","id":"penguins-study","chapter":"8 .  준비된 데이터","heading":"8.1.1 펭귄 공부","text":"팔머(Palmer) 펭귄은 3종이 있으며 자세한 내용은 다음 링크된 나무위키에서 참조 가능하다.젠투 펭귄(Gentoo Penguin): 머리에 모자처럼 둘러져 있는 하얀 털 때문에 알아보기가 쉽다. 암컷이 회색이 뒤에, 흰색이 앞에 있다. 펭귄들 중에 가장 빠른 시속 36km의 수영 실력을 자랑하며, 짝짓기 할 준비가 된 펭귄은 75-90cm까지도 자란다.아델리 펭귄(Adelie Penguin): 프랑스 탐험가인 뒤몽 뒤르빌(Dumont D’Urville) 부인의 이름을 따서 ’아델리’라 불리게 되었다. 각진 머리와 작은 부리 때문에 알아보기 쉽고, 다른 펭귄들과 마찬가지로 암수가 비슷하게 생겼지만 암컷이 조금 더 작다.턱끈 펭귄(Chinstrap Penguin): 언뜻 보면 아델리 펭귄과 매우 비슷하지만, 몸집이 조금 더 작고, 목에서 머리 쪽으로 이어지는 검은 털이 눈에 띈다. 어린 고삐 펭귄들은 회갈색 빛을 띄는 털을 가지고 있으며, 목 아래 부분은 더 하얗다. 무리를 지어 살아가며 일부일처제를 지키기 때문에 짝짓기 이후에도 부부로써 오랫동안 함께 살아간다.팔머 펭귄 3종 세트다음으로 iris 데이터와 마찬가지로 펭귄 3종을 구분하기 위한 변수로 조류의 부리에 있는 중앙 세로선의 융기를 지칭하는 능선(culmen) 길이(culmen length)와 깊이(culmen depth)를 이해하면 된다.팔머 펭귄 능선 변수","code":""},{"path":"ggplot-datasets.html","id":"penguin-install-dataset","chapter":"8 .  준비된 데이터","heading":"8.1.2 데이터셋 설치","text":"CRAN에 등록되어 있어 install.packages() 함수로 직접 설치해도 되고,\nremotes 팩키지 install_github() 함수로 GitHub 저장소의 팔머펭귄 데이터를 설치해도 된다.\n정식 CRAN에 등록되기 이전에 GitHub에 먼저 등록되어 몇년간 정제과정을 거쳐 초기부터 사용하신 분은\nGitHub 저장소 설치가 편할 수 있다. 안정화 되었기 때문에 CRAN 데이터나 GitHub 데이터나 이제 차이는 없다.도서관에서 책을 꺼내 열람실에서 살펴보듯이 설치된 palmerpenguins 데이터셋을\nlibrary(palmerpenguins) 함수로 불러온다. 책에 어떤 내용이 담겼는지 살펴보듯이\ntidyverse를 구성하는 dplyr 패키지 glimpse() 함수로 펭귄 데이터를 일별한다.","code":"## Rows: 344\n## Columns: 8\n## $ species           <fct> Adelie, Adelie, Adelie, Adelie, Adelie, Adelie, Adel…\n## $ island            <fct> Torgersen, Torgersen, Torgersen, Torgersen, Torgerse…\n## $ bill_length_mm    <dbl> 39.1, 39.5, 40.3, NA, 36.7, 39.3, 38.9, 39.2, 34.1, …\n## $ bill_depth_mm     <dbl> 18.7, 17.4, 18.0, NA, 19.3, 20.6, 17.8, 19.6, 18.1, …\n## $ flipper_length_mm <int> 181, 186, 195, NA, 193, 190, 181, 195, 193, 190, 186…\n## $ body_mass_g       <int> 3750, 3800, 3250, NA, 3450, 3650, 3625, 4675, 3475, …\n## $ sex               <fct> male, female, female, NA, female, male, female, male…\n## $ year              <int> 2007, 2007, 2007, 2007, 2007, 2007, 2007, 2007, 2007…"},{"path":"ggplot-datasets.html","id":"penguin-EDA-skimr","chapter":"8 .  준비된 데이터","heading":"8.1.3 자료구조 일별","text":"skimr 패키지를 사용해서\npenguins 데이터프레임 자료구조를 일별한다.\n이를 통해서 344개 펭귄 관측값이 있으며, 7개 칼럼으로 구성된 것을 확인할 수 있다.\n또한, 범주형 변수가 3개, 숫자형 변수가 4개로 구성되어 있다.\n그외 더 자세한 사항은 범주형, 숫자형 변수에 대한 요약 통계량을 참조한다.Table 8.1: Data summaryVariable type: factorVariable type: numeric데이터가 크지 않아 인터랙티브 reactive, DT 패키지를 통해 전체 데이터를 살펴볼 수도 있고,\n첫 10개 관측점만 뽑아 일별할 수도 있다.","code":"## # A tibble: 10 × 8\n##   species island bill_length_mm bill_depth_mm flipper_length_… body_mass_g sex  \n##   <fct>   <fct>           <dbl>         <dbl>            <int>       <int> <fct>\n## 1 Adelie  Torge…           39.1          18.7              181        3750 male \n## 2 Adelie  Torge…           39.5          17.4              186        3800 fema…\n## 3 Adelie  Torge…           40.3          18                195        3250 fema…\n## 4 Adelie  Torge…           NA            NA                 NA          NA <NA> \n## 5 Adelie  Torge…           36.7          19.3              193        3450 fema…\n## 6 Adelie  Torge…           39.3          20.6              190        3650 male \n## # … with 4 more rows, and 1 more variable: year <int>"},{"path":"ggplot-datasets.html","id":"penguin-EDA","chapter":"8 .  준비된 데이터","heading":"8.1.4 탐색적 데이터 분석","text":"palmerpenguins 데이터셋 소개에 포함되어 있는 미국 팔머 연구소 (palmer station)\n펭귄 물갈퀴(flipper) 길이와 체질량(body mass) 산점도를 그려보자.\n그래프 문법에 따라 x, y 축을 데이터프레임 변수로 매핑하고\n산점도의 각 펭귄 물갈퀴 길이(flipper_length_mm)와 체질량(body_mass_g)은\n펭귄 종에 따라 geom_point()로 색상과 모양을 달리한다.","code":""},{"path":"ggplot-datasets.html","id":"gapminder","chapter":"8 .  준비된 데이터","heading":"8.2 갭마인더","text":"‘팩트풀니스’(Factfullness)는 ’사실충실성’으로 번역되고 팩트(사실)에 근거해 세계를 바라보고 이해하는 태도와 관점을 의미하는 것으로 얼마전 타계한 한스 로슬링의 마지막 저서 “Factfulness”의 책제목으로 더 유명하다. 저자는 세계에 관한 심각한 무지와 싸움을 평생의 사명으로 삼아 다양한 업적을 남겼으며 데이터 시각화를 통해 그동안 보지 못했던 사실을 일반인이면 누구나 쉽게 이해하고 의사결정을 빠른 시간내에 내릴 수 있도록 도움을 주였다. 그가 남긴 업적중의 하나는 데이터로 통상 gapminder 로 알려져 있으며 제니 브라이언트 박사가 R 데이터 패키지로 제작하여 쉽게 다가설 수 있게 되었다. gapminder 데이터는 시각화는 물론 애니메이션 시각화의 예제로도 많이 사용되고 있다.갭마인더 데이터셋은 1952년부터 5년 간격으로 2007년까지 142개 국가 인구수, 기대수명(lifeExp), 인구수(pop),\n1인당 국민소득(gdpPercap)에 대한 정보를 담고 있어 기대수명과 1인당 국민소득을 통해 1952년부터 국가별 발전사항 다른 관점으로 불평등에 대한 사실을 시각화를 통해 직시할 수 있다.","code":""},{"path":"ggplot-datasets.html","id":"gapminder-install-dataset","chapter":"8 .  준비된 데이터","heading":"8.2.1 데이터셋 설치","text":"CRAN에 등록되어 있어 install.packages() 함수로 직접 설치해도 되고,\nremotes 팩키지 install_github() 함수로 GitHub 저장소의 갭마인더 데이터를 설치해도 된다.\n팔머 펭귄 데이터와 마찬가지로 안정화 되었기 때문에 CRAN 데이터나 GitHub 데이터나 이제 차이는 없다.","code":""},{"path":"ggplot-datasets.html","id":"gapminder-EDA-skimr","chapter":"8 .  준비된 데이터","heading":"8.2.2 자료구조 일별","text":"skimr 패키지를 사용해서\ngapminder 데이터프레임 자료구조를 일별한다.\n이를 통해서 1,704개 펭귄 관측값이 있으며, 6개 칼럼으로 구성된 것을 확인할 수 있다.\n또한, 범주형 변수가 2개, 숫자형 변수가 4개로 구성되어 있다.\n그외 더 자세한 사항은 범주형, 숫자형 변수에 대한 요약 통계량을 참조한다.Table 8.2: Data summaryVariable type: factorVariable type: numeric데이터가 크지 않아 인터랙티브 reactive, DT 패키지를 통해 전체 데이터를 살펴볼 수도 있고,\n첫 10개 관측점만 뽑아 일별할 수도 있다.","code":"## # A tibble: 10 × 6\n##   country     continent  year lifeExp      pop gdpPercap\n##   <fct>       <fct>     <int>   <dbl>    <int>     <dbl>\n## 1 Afghanistan Asia       1952    28.8  8425333      779.\n## 2 Afghanistan Asia       1957    30.3  9240934      821.\n## 3 Afghanistan Asia       1962    32.0 10267083      853.\n## 4 Afghanistan Asia       1967    34.0 11537966      836.\n## 5 Afghanistan Asia       1972    36.1 13079460      740.\n## 6 Afghanistan Asia       1977    38.4 14880372      786.\n## # … with 4 more rows"},{"path":"ggplot-datasets.html","id":"gapminder-EDA","chapter":"8 .  준비된 데이터","heading":"8.2.3 탐색적 데이터 분석","text":"gapminder 데이터셋에서 dplyr 패키지 filter() 함수를 이용하여 대륙명이 오세아니아를\n제외하고 나머지 대륙(아프리카, 아메리카, 아시아, 유럽)에 속한\n국가를 색상을 달리하여 각 국가별로 연도별 기대수명의 변화를 시각화한다.","code":""},{"path":"tidy-data-how.html","id":"tidy-data-how","chapter":"9 .  깔끔화 방법","heading":"9 .  깔끔화 방법","text":"","code":""},{"path":"tidy-data-how.html","id":"tidyr-verbs-how","chapter":"9 .  깔끔화 방법","heading":"9.1 깔끔화 동사","text":"dplyr 패키지 데이터 문법에 select, filter, mutate, group_by + summarize, arrange 5개 주요 동사(Verb)를\n사용해서 데이터와 커뮤니케이션하며 데이터 조작을 하듯이 tidyr 패키지 깔끔한 데이터 조작 동사를 익혀두면 엉망진창인 데이터에 특효약이다.깔끔한 데이터(Tidy Data)를 만드는데 동원되는 동사에 해당되는 함수는 다음과 같다.\n다음 데이터 깔끔이 함수들을 이용하여 엉망진창인 데이터(Messy Data)를 깔끔한 데이터로 만들어서\n후속 작업에 속도를 높일 수 있다.\ntidyr 팩키지에 포함된 Tidy Data 관련 핵심을 이루는 함수로 다음을 꼽을 수 있다.pivot_longer() / pivot_wider() : 데이터프레임 형태 변환 동사separate(), separate_rows() / unite() : 변수 쪼개고 합하는 동사expand_grid() : 결측값 처리 동사깔끔한 데이터 관련 R 패키지는 해드릴 위컴이 주축이 되어 10년 이상 발전시켜\n완성한 개념으로 그 단계 단계마다 개발된 팩키지가 있고 개념을\n구체화하며 실제로 구현한 함수들도 점점 진화해 나갔다.\n과거 진화과정을 살펴보면 어느 순간 깔끔한 데이터(Tidy Data) 개념과 동시에 도구가\n나온 것이 아니라 경험과 새로운 지식이 축적되며 진화를 거듭한 결과로 볼 수 있다.reshape, reshape2 (Wickham 2007)plyr (Wickham 2011)tidyr (Wickham 2013)엉망진창인 데이터는 빅데이터와 공공데이터가 널려있는 현시점 어디서나 마주할 수 있지만,\n다행히도 앞선 데이터 과학자들이 각자 맞닥드린 문제를 해결하며 경험을 공유하고 있다.\n다음에 나온 사례가 엉망진창 데이터 전부는 아니지만 각 사례별로 깔끔한 데이터로 변환시키는\n과정을 살펴보면 향후 맞닥드릴 수 있는 데이터 문제에 좋은 영감을 줄 것으로 생각된다.","code":""},{"path":"tidy-data-how.html","id":"pivot-revolution","chapter":"9 .  깔끔화 방법","heading":"9.2 pivot_*() 동사","text":"해들리 위컴이 언급했듯이, gather/spread는 사라지지 않고 훨씬 더 나은 모습으로 재탄생했습니다.\npivot_longer(), pivot_wider() 함수는 gather(), spread() 함수를 개선하면서 다른 팩키지의 최신 기능을 추가시켰다.pivot_longer()은 data.table 패키지 melt(), dcast()와 연관됨.cdata 패키지에 영감을 받아 pivot_longer(), pivot_wider() 명칭으로 통일됨.기억하기 좋게 인텍스(index)를 갖는 긴 자료형(long)과 데카르트 평면(Cartesian)과 같은\n넓은(wide) 자료형으로 구분한다.\ntidyr 패키지가 버전 1.0으로 정식 버젼업하면서 생겨난 가장 큰 변화 중 하나가 아닐까 싶다.","code":""},{"path":"tidy-data-how.html","id":"pivot-longer-example","chapter":"9 .  깔끔화 방법","heading":"9.2.1 데카르트 평면 → 인덱스: pivot_longer()","text":"pivot_longer() 함수를 사용해서 데카르트 평면과 같이 넓은 데이터(wide)를 인덱스가 붙은 긴 형태(long) 데이터로 변환시킬 수 있다. relig_income 데이터는 gather/spread 시절부터 자주 예제 데이터로 사용되던 예제 데이터셋이다.religion 변수를 제외하고 나머지 변수가 names_to를 통해 인덱스 명을 바꿀 수 있고 이들이 담고 있던 값은 values_to로 떨어지게 된다.cols: dplyr::select() 구문과 동일하게 작성함.데카르트 평면 넓은 데이터인덱스 긴 형식 데이터","code":"\ndataframe %>% \n  pivot_longer(\n    cols,\n    ...\n  )\nlibrary(tidyr)\n\nrelig_income %>% head## # A tibble: 6 × 11\n##   religion  `<$10k` `$10-20k` `$20-30k` `$30-40k` `$40-50k` `$50-75k` `$75-100k`\n##   <chr>       <dbl>     <dbl>     <dbl>     <dbl>     <dbl>     <dbl>      <dbl>\n## 1 Agnostic       27        34        60        81        76       137        122\n## 2 Atheist        12        27        37        52        35        70         73\n## 3 Buddhist       27        21        30        34        33        58         62\n## 4 Catholic      418       617       732       670       638      1116        949\n## 5 Don’t k…       15        14        15        11        10        35         21\n## 6 Evangeli…     575       869      1064       982       881      1486        949\n## # … with 3 more variables: `$100-150k` <dbl>, `>150k` <dbl>,\n## #   `Don't know/refused` <dbl>\nrelig_income %>% \n  pivot_longer(-religion, names_to=\"소득\", values_to = \"사람수\")## # A tibble: 180 × 3\n##   religion 소득    사람수\n##   <chr>    <chr>    <dbl>\n## 1 Agnostic <$10k       27\n## 2 Agnostic $10-20k     34\n## 3 Agnostic $20-30k     60\n## 4 Agnostic $30-40k     81\n## 5 Agnostic $40-50k     76\n## 6 Agnostic $50-75k    137\n## # … with 174 more rows"},{"path":"tidy-data-how.html","id":"pivot-longer-example-prefix","chapter":"9 .  깔끔화 방법","heading":"9.2.2 접두사(prefix) 제거: pivot_longer()","text":"names_prefix를 사용해서 $, <$, > 붙은 값을 제거시킬 수 있다.","code":"\nrelig_income %>% \n  pivot_longer(-religion, names_to=\"소득\", \n               values_to = \"명수\",\n               names_prefix = \"\\\\$|<\\\\$|>\")## # A tibble: 180 × 3\n##   religion 소득    명수\n##   <chr>    <chr>  <dbl>\n## 1 Agnostic 10k       27\n## 2 Agnostic 10-20k    34\n## 3 Agnostic 20-30k    60\n## 4 Agnostic 30-40k    81\n## 5 Agnostic 40-50k    76\n## 6 Agnostic 50-75k   137\n## # … with 174 more rows"},{"path":"tidy-data-how.html","id":"pivot-longer-example-type","chapter":"9 .  깔끔화 방법","heading":"9.2.3 자료형 변환: pivot_longer()","text":"빌보드 원본 데이터: 자료변환 전일단 주간 순위는 어찌해서 만들었지만, 주간 칼럼에 wk가 들어 있어 이를 names_prefix를 통해 날려버리고 나도 숫자로 되어 있는 문자를 다시 숫자형으로 칼럼 자료형을 바꿔야 한다.빌보드 원본 데이터: 자료변환 후","code":"\nbillboard %>% \n  pivot_longer(\n    cols = starts_with(\"wk\"), \n    names_to = \"주간\", \n    values_to = \"순위\",\n    values_drop_na = TRUE\n  )## # A tibble: 5,307 × 5\n##   artist track                   date.entered 주간   순위\n##   <chr>  <chr>                   <date>       <chr> <dbl>\n## 1 2 Pac  Baby Don't Cry (Keep... 2000-02-26   wk1      87\n## 2 2 Pac  Baby Don't Cry (Keep... 2000-02-26   wk2      82\n## 3 2 Pac  Baby Don't Cry (Keep... 2000-02-26   wk3      72\n## 4 2 Pac  Baby Don't Cry (Keep... 2000-02-26   wk4      77\n## 5 2 Pac  Baby Don't Cry (Keep... 2000-02-26   wk5      87\n## 6 2 Pac  Baby Don't Cry (Keep... 2000-02-26   wk6      94\n## # … with 5,301 more rows\nbillboard %>% \n  pivot_longer(\n    cols = starts_with(\"wk\"), \n    names_to = \"주간\", \n    values_to = \"순위\",\n    names_prefix = \"wk\",\n    names_ptypes = list(`주간` = as.character()),\n    values_drop_na = TRUE\n  )## # A tibble: 5,307 × 5\n##   artist track                   date.entered 주간   순위\n##   <chr>  <chr>                   <date>       <chr> <dbl>\n## 1 2 Pac  Baby Don't Cry (Keep... 2000-02-26   1        87\n## 2 2 Pac  Baby Don't Cry (Keep... 2000-02-26   2        82\n## 3 2 Pac  Baby Don't Cry (Keep... 2000-02-26   3        72\n## 4 2 Pac  Baby Don't Cry (Keep... 2000-02-26   4        77\n## 5 2 Pac  Baby Don't Cry (Keep... 2000-02-26   5        87\n## 6 2 Pac  Baby Don't Cry (Keep... 2000-02-26   6        94\n## # … with 5,301 more rows"},{"path":"tidy-data-how.html","id":"pivot-longer-example-columns","chapter":"9 .  깔끔화 방법","heading":"9.2.4 다수 칼럼: pivot_longer()","text":"데이터셋과 같이 다수 칼럼이 포함된 경우가 있을 수 있다. 이런 경우 names_pattern 정규표현식을 적용시켜 변수를 추출할 수 있다. 먼저 데이터셋을 살펴보자.new_/new 접두어sp/rel/sp/ep 진단 구분m/f 성별014/1524/2535/3544/4554/65 연령대먼저, country, iso2, iso3, year 4개 변수는 정리되어 있어 그대로 두고, 나머지 변수를 dplyr::select 문법에 맞춰 선택하고 이를 변경시킨다.\nnames_to로 변수명 3개를 지정하고, new_/new 접두어는 고정되어 names_pattern에서 정규표현식으로 패턴을 적의한다. 이와 더불어 names_ptypes에서 자료형도 함께 지정한다.","code":"\nwho %>% pivot_longer(\n  cols = new_sp_m014:newrel_f65,\n  names_to = c(\"diagnosis\", \"gender\", \"age\"), \n  names_pattern = \"new_?(.*)_(m|f)(.*)\",\n  names_ptypes = list(\n    gender = factor(levels = c(\"f\", \"m\")),\n    age = factor(\n      levels = c(\"014\", \"1524\", \"2534\", \"3544\", \"4554\", \"5564\", \"65\"), \n      ordered = TRUE\n    )\n  ),\n  values_to = \"count\",\n) %>% \n  arrange(desc(count))## # A tibble: 405,440 × 8\n##   country iso2  iso3   year diagnosis gender age    count\n##   <chr>   <chr> <chr> <int> <chr>     <fct>  <ord>  <int>\n## 1 India   IN    IND    2007 sn        m      3544  250051\n## 2 India   IN    IND    2007 sn        f      3544  148811\n## 3 China   CN    CHN    2013 rel       m      65    124476\n## 4 China   CN    CHN    2013 rel       m      5564  112558\n## 5 India   IN    IND    2007 ep        m      3544  105825\n## 6 India   IN    IND    2007 ep        f      3544  101015\n## # … with 405,434 more rows"},{"path":"tidy-data-how.html","id":"pivot-longer-example-rows","chapter":"9 .  깔끔화 방법","heading":"9.2.5 한행에 다수 관측점: pivot_longer()","text":"한행에 관측점이 다수 있는 재미있는 데이터도 있다.\n즉, 첫번째 가정에 아이가 2명 있는데 첫째 아이 생일과 성별, 둘째 아이 생일과 성별이 한 행에 놓여있는 경우가 이에 해당된다.이를 원하는 이름으로 변경시키기 위해서 names_to=에 .value라는 특수명칭을 사용하여 한 관측점에 다수 관측점 정보가 포함된 문제를 해결한다.","code":"\nfamily <- tribble(\n  ~family,  ~dob_child1,  ~dob_child2, ~gender_child1, ~gender_child2,\n       1L, \"1998-11-26\", \"2000-01-29\",             1L,             2L,\n       2L, \"1996-06-22\",           NA,             2L,             NA,\n       3L, \"2002-07-11\", \"2004-04-05\",             2L,             2L,\n       4L, \"2004-10-10\", \"2009-08-27\",             1L,             1L,\n       5L, \"2000-12-05\", \"2005-02-28\",             2L,             1L,\n)\nfamily## # A tibble: 5 × 5\n##   family dob_child1 dob_child2 gender_child1 gender_child2\n##    <int> <chr>      <chr>              <int>         <int>\n## 1      1 1998-11-26 2000-01-29             1             2\n## 2      2 1996-06-22 <NA>                   2            NA\n## 3      3 2002-07-11 2004-04-05             2             2\n## 4      4 2004-10-10 2009-08-27             1             1\n## 5      5 2000-12-05 2005-02-28             2             1\nfamily %>% \n  pivot_longer(\n    -family, \n    names_to = c(\".value\", \"child\"), \n    names_sep = \"_\", \n    values_drop_na = TRUE\n  ) %>% \n  dplyr::mutate(dob = parse_date(dob))## # A tibble: 9 × 4\n##   family child  dob        gender\n##    <int> <chr>  <date>      <int>\n## 1      1 child1 1998-11-26      1\n## 2      1 child2 2000-01-29      2\n## 3      2 child1 1996-06-22      2\n## 4      3 child1 2002-07-11      2\n## 5      3 child2 2004-04-05      2\n## 6      4 child1 2004-10-10      1\n## # … with 3 more rows"},{"path":"tidy-data-how.html","id":"pivot-longer-example-duplicated","chapter":"9 .  깔끔화 방법","heading":"9.2.6 칼럼명이 중복됨: pivot_longer()","text":"종복된 칼럼명이 존재하는 경우 작업하기 까다로운데… pivot_longer()에서 자동으로 칼럼을 추가시켜 문제를 풀어준다.중복칼럼 데이터셋중복칼럼 데이터셋 작업결과","code":"\ndf <- tibble(x = 1:3, y = 4:6, y = 5:7, y = 7:9, .name_repair = \"minimal\")\ndf## # A tibble: 3 × 4\n##       x     y     y     y\n##   <int> <int> <int> <int>\n## 1     1     4     5     7\n## 2     2     5     6     8\n## 3     3     6     7     9\ndf %>% \n  pivot_longer(-x, names_to = \"name\", values_to = \"value\")## # A tibble: 9 × 3\n##       x name  value\n##   <int> <chr> <int>\n## 1     1 y         4\n## 2     1 y         5\n## 3     1 y         7\n## 4     2 y         5\n## 5     2 y         6\n## 6     2 y         8\n## # … with 3 more rows"},{"path":"tidy-data-how.html","id":"pivot-longer-wider","chapter":"9 .  깔끔화 방법","heading":"9.3 인덱스 → 데카르트 평면: pivot_wider()","text":"pivot_wider()는 깔끔한 데이터를 만드는데 그다지 흔한 경우는 아니지만, 요약표를 만드거나 할 때 종종 사용되고, pivot_longer()와 정반대라고 보면 된다.names_from은 칼럼값을 지정하는 칼럼values-from은 값(value)을 지정하는 칼럼tidyr::fish_encounters 패키지에 내장된 fish_encounters 데이터셋은 “Visualizing Fish Encounter Histories”, February 3 2018에 나온 물고기 포획 방류, 재포획 즉, capture-recapture 데이터셋이다. pivot_wider() 함수에 names_from, value_from을 지정하여 데카르트 평면에 좌표로 찍듯이 데이터를 펼친다. 결측값이 생기는 것은 values_fill을 사용해서 0으로 채워넣게 되면 결측값도 정리되고 사람이 이해하기 쉬운 데이터로 즉시 일별하여 확인이 가능하다.깔끔한 데이터: 인덱스 긴 형식요약표 형태 데이터","code":"\ndataframe %>% \n  pivot_wider(\n    names_from,\n    values_from,\n    ...\n  )\nfish_encounters## # A tibble: 114 × 3\n##   fish  station  seen\n##   <fct> <fct>   <int>\n## 1 4842  Release     1\n## 2 4842  I80_1       1\n## 3 4842  Lisbon      1\n## 4 4842  Rstr        1\n## 5 4842  Base_TD     1\n## 6 4842  BCE         1\n## # … with 108 more rows\nfish_encounters %>% \n  pivot_wider(names_from = station, \n              values_from = seen,\n              values_fill = list(seen = 0)) %>% \n  head(10)## # A tibble: 10 × 12\n##   fish  Release I80_1 Lisbon  Rstr Base_TD   BCE   BCW  BCE2  BCW2   MAE   MAW\n##   <fct>   <int> <int>  <int> <int>   <int> <int> <int> <int> <int> <int> <int>\n## 1 4842        1     1      1     1       1     1     1     1     1     1     1\n## 2 4843        1     1      1     1       1     1     1     1     1     1     1\n## 3 4844        1     1      1     1       1     1     1     1     1     1     1\n## 4 4845        1     1      1     1       1     0     0     0     0     0     0\n## 5 4847        1     1      1     0       0     0     0     0     0     0     0\n## 6 4848        1     1      1     1       0     0     0     0     0     0     0\n## # … with 4 more rows"},{"path":"tidy-data-how.html","id":"pivot-longer-wider-aggregation","chapter":"9 .  깔끔화 방법","heading":"9.3.1 총계(aggregation): pivot_wider()","text":"pivot_wider()를 통해 총계(aggregate)를 내야하는 상황이 발생하곤 한다.\ndatasets 패키지에 내장된 실험계획법이 적용된 데이터 warpbreaks를 보면 wool, tension 두가지 요인으로 총 9번 실험한 결과가 breaks에 담겨진 것을 확인할 수 있다.현재 인덱스로 잘 정제된 긴형태 데이터를 요약표 형태로 데카르트 평면과 같이 정리하고자 하면 다음과 같이 작업하게 되면 wool, tension 요인별로 총 9개 breaks값이 한 곳에 몰려있는 것을 파악할 수 있다. values_fn을 사용해서 총계로 평균, 최대, 최소 등을 사용해서 하나의 값으로 요약할 수 있다.요인별 원데이터요인별 총계: 최대값","code":"\nwarpbreaks <- datasets::warpbreaks %>% \n  as_tibble() %>% \n  select(wool, tension, breaks)\n\nwarpbreaks %>% \n  count(wool, tension)## # A tibble: 6 × 3\n##   wool  tension     n\n##   <fct> <fct>   <int>\n## 1 A     L           9\n## 2 A     M           9\n## 3 A     H           9\n## 4 B     L           9\n## 5 B     M           9\n## 6 B     H           9\nwarpbreaks %>% \n  pivot_wider(\n    names_from = wool,\n    values_from = breaks\n  )## # A tibble: 3 × 3\n##   tension A         B        \n##   <fct>   <list>    <list>   \n## 1 L       <dbl [9]> <dbl [9]>\n## 2 M       <dbl [9]> <dbl [9]>\n## 3 H       <dbl [9]> <dbl [9]>\nwarpbreaks %>% \n  pivot_wider(\n    names_from = wool,\n    values_from = breaks,\n    values_fn = list(breaks = max)\n  )## # A tibble: 3 × 3\n##   tension     A     B\n##   <fct>   <dbl> <dbl>\n## 1 L          70    44\n## 2 M          36    42\n## 3 H          43    28"},{"path":"tidy-data-how.html","id":"separate-unite-verbs","chapter":"9 .  깔끔화 방법","heading":"9.4 separate()와 unite()","text":"","code":""},{"path":"tidy-data-how.html","id":"separate-columns","chapter":"9 .  깔끔화 방법","heading":"9.4.1 칼럼에 변수 두개 포함","text":"칼럼 하나에 다수 변수가 포함된 경우를 흔히 발견할 수 있다. dplyr 팩키지에는 starwars 데이터셋에 등장하는 인물에 대한 인적정보가 담겨있다. 예를 들어, name 칼럼은 두 변수가 숨어 있다. 하나는 성(last name) 다른 하나는 이름(first name)이다. 이를 두개로 쪼개어 두는 것이 Tidy Data를 만든다고 볼 수 있다. 꼭 그런 것은 아니고 경우에 따라 차이가 있지만, 개념적으로 그렇다는 것이다. 상황에 맞춰 유연하게 사용한다.separate() 함수를 사용해서 칼럼을 두개로 쪼갠다. 이런 경우 sep= 인자를 통해 구분자를 지정한다. 공백, ;, , 등 문제에 따라 구분자를 달리 사용한다.","code":"\nstarwars_name_df <- dplyr::starwars %>% \n  select(name, species, height, mass) %>% \n  filter(str_detect(species, \"Human\"))\n\nstarwars_name_df## # A tibble: 35 × 4\n##   name               species height  mass\n##   <chr>              <chr>    <int> <dbl>\n## 1 Luke Skywalker     Human      172    77\n## 2 Darth Vader        Human      202   136\n## 3 Leia Organa        Human      150    49\n## 4 Owen Lars          Human      178   120\n## 5 Beru Whitesun lars Human      165    75\n## 6 Biggs Darklighter  Human      183    84\n## # … with 29 more rows\nstarwars_name_df %>% \n  separate(name, into = c(\"first_name\", \"last_name\"), sep=\" \")## # A tibble: 35 × 5\n##   first_name last_name   species height  mass\n##   <chr>      <chr>       <chr>    <int> <dbl>\n## 1 Luke       Skywalker   Human      172    77\n## 2 Darth      Vader       Human      202   136\n## 3 Leia       Organa      Human      150    49\n## 4 Owen       Lars        Human      178   120\n## 5 Beru       Whitesun    Human      165    75\n## 6 Biggs      Darklighter Human      183    84\n## # … with 29 more rows"},{"path":"tidy-data-how.html","id":"separate-columns-many","chapter":"9 .  깔끔화 방법","heading":"9.4.2 칼럼에 변수 다수 포함","text":"TidyTuesday에서 나왔던 칵테일 데이터를 보게 되면 각 칵테일을 제작하는데 필요한 재표가 ingredient 칼럼 안에 콤마(,)로 묶여있다. 이런 데이터는 절대로 Tidy한 데이터가 아니라서 적절한 조치가 필요하다.먼저 stringr 팩키지 str_split() 함수로 ingredient 칼럼을 ,을 구분자로 삼아 쪼갠 후에 list-column 형태 칼럼(ingredient_lc)으로 저장시킨다. 그리고 나서 unnest() 함수로 중첩된 것을 풀게 되면 다음과 같은 티블 데이터프레임이 되어 Tidy Data로 변환된다.자, 이제 깔끔한 데이터의 힘을 느껴보자. 칵테일 중에 가장 다양한 재료가 포함된 칵테일은 무엇인가? 라는 질문에 단순한 dplyr 동사로 확인이 바로 가능하다.","code":"\n# cocktail_data <- tidytuesdayR::tt_load('2020-05-26')\n\ncocktails <- readr::read_csv('https://raw.githubusercontent.com/rfordatascience/tidytuesday/master/data/2020/2020-05-26/cocktails.csv')\n\ncocktail_df <- cocktails %>% \n  select(drink, ingredient)\n\ncocktail_tbl <- cocktail_df %>% \n  group_by(drink) %>% \n  nest() %>% \n  mutate(ingredient_tmp = map(data, function(df) df %>%  select(ingredient) %>% pull) ) %>% \n  mutate(ingredient = map_chr(ingredient_tmp, paste, collapse = \", \")) %>% \n  ungroup \n\ncocktail_tbl %>% \n  select(drink, ingredient)## # A tibble: 546 × 2\n##   drink                                ingredient                               \n##   <chr>                                <chr>                                    \n## 1 '57 Chevy with a White License Plate Creme de Cacao, Vodka                    \n## 2 1-900-FUK-MEUP                       Absolut Kurant, Grand Marnier, Chambord …\n## 3 110 in the shade                     Lager, Tequila                           \n## 4 151 Florida Bushwacker               Malibu rum, Light rum, 151 proof rum, Da…\n## 5 155 Belmont                          Dark rum, Light rum, Vodka, Orange juice \n## 6 24k nightmare                        Goldschlager, Jägermeister, Rumple Minze…\n## # … with 540 more rows\ncocktails_tbl <- cocktail_tbl %>% \n  select(drink, ingredient) %>% \n  mutate(ingredient_lc = str_split(ingredient, \", \")) %>% \n  unnest(ingredient_lc)\n\ncocktails_tbl## # A tibble: 2,104 × 3\n##   drink                                ingredient                  ingredient_lc\n##   <chr>                                <chr>                       <chr>        \n## 1 '57 Chevy with a White License Plate Creme de Cacao, Vodka       Creme de Cac…\n## 2 '57 Chevy with a White License Plate Creme de Cacao, Vodka       Vodka        \n## 3 1-900-FUK-MEUP                       Absolut Kurant, Grand Marn… Absolut Kura…\n## 4 1-900-FUK-MEUP                       Absolut Kurant, Grand Marn… Grand Marnier\n## 5 1-900-FUK-MEUP                       Absolut Kurant, Grand Marn… Chambord ras…\n## 6 1-900-FUK-MEUP                       Absolut Kurant, Grand Marn… Midori melon…\n## # … with 2,098 more rows\ncocktails_tbl %>% \n  group_by(drink) %>% \n  summarise(num_ingredients = n()) %>% \n  arrange(desc(num_ingredients))## # A tibble: 546 × 2\n##   drink                  num_ingredients\n##   <chr>                            <int>\n## 1 Angelica Liqueur                    12\n## 2 Amaretto Liqueur                    11\n## 3 Egg Nog #4                          11\n## 4 Arizona Twister                      9\n## 5 1-900-FUK-MEUP                       8\n## 6 151 Florida Bushwacker               8\n## # … with 540 more rows"},{"path":"tidy-data-how.html","id":"separete-rows-quickly","chapter":"9 .  깔끔화 방법","heading":"9.4.3 separate_rows() 함수로 빠르게","text":"상기 과정이 다소 많은 동사를 조합해서 결과를 도출하고 있다고 생각된다면 separate_rows() 함수를 사용해서 깔끔한 데이터를 만든 후에 count 함수와 sort = TRUE를 활용하여 동일한 작업을 간단히 마무리 할 수 있다.","code":"\ncocktail_tbl %>% \n  separate_rows(ingredient, sep = \", \") %>% \n  count(drink, sort = TRUE)## # A tibble: 546 × 2\n##   drink                      n\n##   <chr>                  <int>\n## 1 Angelica Liqueur          12\n## 2 Amaretto Liqueur          11\n## 3 Egg Nog #4                11\n## 4 Arizona Twister            9\n## 5 1-900-FUK-MEUP             8\n## 6 151 Florida Bushwacker     8\n## # … with 540 more rows"},{"path":"tidy-data-how.html","id":"fix-missing-data","chapter":"9 .  깔끔화 방법","heading":"9.5 결측 데이터","text":"data.world Nuclear Weapon Explosions THOMAS DRÄBING 웹사이트에서 핵폭탄 실험 데이터를 다운로드 받을 수 있다.\n데이터 자체는 완벽하지만 의미상 문제가 있다.\n즉 1945년 이후 데이터를 보자면 숨어있는 결측값이 보인다.\n확인이 안된 것 한건 빼면 7개국이 핵폭탄 실험을 한 것으로 나오는데 1945년에는 아무런 기록이 없다.\n데이터프레임에는 정상인 깔끔한 데이터지만 사실 1945년 0 건에 예를 들어 중국이나 러시아가 포함되어 있는 것이 맞다.\n이런 데이터 자체 결측값을 찾아내서 채워넣는 것이 깔끔한 데이터를 만드는 또하나 중요한 과정이다.","code":"\nlibrary(lubridate)\n\nnuclear_raw <- read_csv(\"data/nuclear_weapon_explosions_1945-1998.csv\")\n\nnuclear_trials_df <- nuclear_raw %>% \n  janitor::clean_names() %>% \n  mutate(datetime = lubridate::parse_date_time(datetime, \"%m/%d/%Y %H:%M:%S %p\")) %>% \n  mutate(연도 = year(datetime)) %>% \n  count(country, 연도, name = \"핵실험횟수\") %>% \n  rename(국가 = country) %>% \n  arrange(연도) %>% \n  filter(연도 <= 1954)\n\nnuclear_trials_df ## # A tibble: 13 × 3\n##   국가    연도 핵실험횟수\n##   <chr>  <dbl>      <int>\n## 1 USA     1945          3\n## 2 USA     1946          2\n## 3 USA     1948          3\n## 4 Russia  1949          1\n## 5 Russia  1951          2\n## 6 USA     1951         16\n## # … with 7 more rows"},{"path":"tidy-data-how.html","id":"expand-grid-comes-in","chapter":"9 .  깔끔화 방법","heading":"9.5.1 결측값 명시: expand_grid()","text":"상기와 같은 문제를 해결하기 위해 expand_grid() 함수를 사용해서 핵실험을 수행한 모든 국가에 대해 해당 년도를 모두 생성할 필요가 있다.\n3개 국가에 대해 10년을 expand_grid() 함수로 조합하게 되면 30개 관측점이 생기는데 미국이 핵실험을 하지 않은 1947년의 경우 NA 값이 생긴다. 이를 채워주어야 한다. 앞서 expand_grid() 함수로 생성된 Tidy Data를 염두에 두고 이를 left_join() 함수와 조인을 걸어 나중에 치환시킬 데이터프레임을 사전 제작한다.","code":"\ncountry_year_tbl <- expand_grid(국가 = c(\"USA\", \"Russia\", \"England\"),\n                               연도 = seq(1945, 1954, 1))\n\nnuclear_tbl <- country_year_tbl %>% \n  left_join(nuclear_trials_df)\n\nnuclear_tbl## # A tibble: 30 × 3\n##   국가   연도 핵실험횟수\n##   <chr> <dbl>      <int>\n## 1 USA    1945          3\n## 2 USA    1946          2\n## 3 USA    1947         NA\n## 4 USA    1948          3\n## 5 USA    1949         NA\n## 6 USA    1950         NA\n## # … with 24 more rows"},{"path":"tidy-data-how.html","id":"expand-grid-comes-in-replace_na","chapter":"9 .  깔끔화 방법","heading":"9.5.2 결측값 치환: replace_na()","text":"결측값을 특정 값으로 채워 넣고자 하는 경우 replace_na() 함수를 사용한다.\n먼저 replace_na() 함수를 사용해서 n_bombs 변수에 NA 결측값을 0으로 채워넣는다.\n다른 국가명이나 연도에 결측값이 있는 경우 동일하게 변수명을 지정하고 결측값을 지정하여 해결한다.","code":"\nnuclear_tbl %>% \n  replace_na(list(핵실험횟수 = 0,\n                  연도 = 1945))## # A tibble: 30 × 3\n##   국가   연도 핵실험횟수\n##   <chr> <dbl>      <int>\n## 1 USA    1945          3\n## 2 USA    1946          2\n## 3 USA    1947          0\n## 4 USA    1948          3\n## 5 USA    1949          0\n## 6 USA    1950          0\n## # … with 24 more rows"},{"path":"tidy-data-how.html","id":"expand-grid-comes-in-drop","chapter":"9 .  깔끔화 방법","heading":"9.5.3 결측값 제거: drop_na()","text":"다른 것 다 모르겠고 데이터프레임에 결측값이 있으면 안되기 때문에 그냥 제거한다.\n이럴 때 사용하는 함수가 drop_na()다.","code":"\nnuclear_tbl %>% \n  drop_na(핵실험횟수)## # A tibble: 13 × 3\n##   국가   연도 핵실험횟수\n##   <chr> <dbl>      <int>\n## 1 USA    1945          3\n## 2 USA    1946          2\n## 3 USA    1948          3\n## 4 USA    1951         16\n## 5 USA    1952         10\n## 6 USA    1953         11\n## # … with 7 more rows"},{"path":"시각화.html","id":"시각화","chapter":"시각화","heading":"시각화","text":"","code":""},{"path":"ggplot.html","id":"ggplot","chapter":"10 .  그래프 문법","heading":"10 .  그래프 문법","text":"","code":""},{"path":"ggplot.html","id":"why-ggplot2","chapter":"10 .  그래프 문법","heading":"10.1 그래프 문법의 존재이유","text":"Leland Wilkinson의 “Grammar Graphics”는 1999년 첫 출간된 이후 데이터 그래픽(data graphics)에 많은 영향을 주어 ggplot2, Polaris → Tableau, Vega-Lite 등의 형태로 우리곁에 다가섰다.\n기존 데이터를 시각화한 다양한 그래픽 객체를 만드려면 각 그래픽 객체별로 따로 사용법을 익혀야만 되었다.\n이것이 갖는 한계는 그래프 종류가 적은 경우 유용하지만 그래프 종류가 많아지면 매번 따로 사용법을 배워야되서\n확장가능성이 무척 떨어지게 된다.\n그래서, 이를 일반화한 무언가 필요한데 데이터 그래픽 객체를 분해해서 8개 계층으로 분해하여 조립하여\n그래프를 제작하게 되면 앞선 문제를 일거에 해소할 수 있다.\n그래프 문법(grammar graphics)을 통해 데이터를 가장 잘 표현할 수 있는 그래프를 생성할 수 있게 되었다.ggplot이 필요한 이유","code":""},{"path":"ggplot.html","id":"ggplot2-steps","chapter":"10 .  그래프 문법","heading":"10.2 그래프 문법","text":"그래프 문법은 총 8가지 층으로 구성되어 있는데 이를 각 층별로 나눠보면 다음과 같다.","code":""},{"path":"ggplot.html","id":"ggplot2-steps-data","chapter":"10 .  그래프 문법","heading":"10.2.1 데이터(Data)","text":"그래프 문법 ggplot에 데이터는 깔끔한 데이터(tidy data)를 가정한다. 이를 위해서 기존 wide형태 데이터는 key-value long 형태로 바뀌어 준비한다.깔끔한 데이터 wide, long 데이터","code":""},{"path":"ggplot.html","id":"ggplot2-steps-mapping","chapter":"10 .  그래프 문법","heading":"10.2.2 매핑(Mapping)","text":"깔끔한 데이터가 준비되면 다음 단계로 칼럼에 해당되는 각 변수를 aes() 함수를 사용해서 aes(x=x, y=y, color=z, ...)와 같은 방식으로 데이터와 그래프를 매핑한다.데이터를 그래프에 매핑","code":""},{"path":"ggplot.html","id":"ggplot2-steps-statistics","chapter":"10 .  그래프 문법","heading":"10.2.3 통계량(statistics)","text":"범주형 그래프를 시각화할 경우 빈도수를 통계량으로 계산해놔야 하고, 연속형 변수를 히스토그램으로 표현할 때도 마찬가지 방식으로 구간별 빈도수를 계산해놔야 하고, 특히 상자그림(boxplot)을 시각화할 경우 각 분위수는 물론이고 중위수도 및 interquantile도 계산해서 수염의 끝도 계산해놔야 제대로된 상자그림을 시각화할 수 있다.그래프별 기본설정 통계량","code":""},{"path":"ggplot.html","id":"ggplot2-steps-scales","chapter":"10 .  그래프 문법","heading":"10.2.4 척도(scales)","text":"X축, Y축의 척도를 그래프에서 자동으로 인식하는데는 한계가 있어 이를 필요한 경우 적절한 형태로 설정한다. scale_<x, y, color, fill, ...>_<유형>() 구문을 갖는다. 예를 들어 Y축을 담당하는 변수가 로그척도(log)가 적합한 경우 이를 scale_y_log10()와 같이 변수를 특성을 반영한 척도를 설정한다. 변수가 날짜나 시간인 경우 scale_x_date(), scale_x_datetime()을 활용하여 적절한 형태로 설정한다.aes 매핑된 축 척도지정","code":""},{"path":"ggplot.html","id":"ggplot2-steps-geometries","chapter":"10 .  그래프 문법","heading":"10.2.5 기하형상(geometries)","text":"예를 들어, 범주형 변수를 aes()로 지정하고 이를 적절한 그래프로 표현하기 위한 결정과정으로 geom_*() 방식으로 원그래프, 막대그래프, 점그래프 등으로 변수를 시각화객체로 지정한다.기하형상 지정","code":""},{"path":"ggplot.html","id":"ggplot2-steps-facet","chapter":"10 .  그래프 문법","heading":"10.2.6 작은 창(facet)","text":"원본 데이터를 그룹으로 쪼개 작은 창에 동일한 시각화 객체를 표현하는 방법으로 다차원 데이터를 차원별로 나눠 볼 수 있다. 중요한 점은 각 작은 창이 동일한 유형의 그래프라는 점이 중요하다.그룹으로 쪼갠 작은 창(facet)","code":""},{"path":"ggplot.html","id":"ggplot2-steps-coordinate","chapter":"10 .  그래프 문법","heading":"10.2.7 좌표계(coordinate)","text":"깔끔한 데이터를 그래프에 매칭하여 시각화한 후에 경우에 따라서 좌표계를 변경할 경우가 있다. coord_fixed(), coord_polar(), coord_flip() 등을 사용해서 특정 영역 확대, 데카르트 좌표계에서 극좌표계, X-Y 축 변경 등의 작업을 수행할 수 있다.좌표계 변환","code":""},{"path":"ggplot.html","id":"ggplot2-steps-theme","chapter":"10 .  그래프 문법","heading":"10.2.8 분위기 풍(theme)","text":"분위기 풍(theme)은 앞선 깔끔한 데이터를 시각화 객체로 변환시키는 과정과 아무런 연관이 없다. 대신 외양을 보기좋게 하는 역할을 수행한다. 즉, 시각화에 알맞는 색상 팔레트를 적용시키고, 글꼴을 바꾸는 작업이 여기에 해당된다.tufte 분위기 풍(theme)","code":""},{"path":"ggplot.html","id":"ggplot2-steps-extension","chapter":"10 .  그래프 문법","heading":"10.3 ggplot 확장","text":"기본 ggplot 그래프 객체를 갖게 되면 2개 이상의 그래프를 합치거나 배열을 달리하고,\n강조를 하고 주석(annotation)을 달고 애니메이션과 인터랙티브 기능을 추가하여 확장시킬 수 있다.","code":""},{"path":"ggplot-visualization.html","id":"ggplot-visualization","chapter":"11 .  ggplot 시각화","heading":"11 .  ggplot 시각화","text":"학계 논문, 산업계 발표장표, 산학연구기관에서 발간하는 보고서에\n즉시 사용할 수 있는 시각화 그래프를 어떻게 제작할 것인가?\n이 문제에 가장 기본이 되는 것은 추적가능하고 재현가능한 시각화 그래프를\n제작하여 체계적으로 관리하는 것이다. 특히, 그래프가 데이터에 근거하여\n제작되는 그래프는 더욱 그렇다.\n소프트웨어 카펜트리 “재현가능한 과학적 분석을 위한 R” 내용을 바탕으로\n저자의 경험과 최근 시각화 패키지를 반영했습니다. (이광춘 2018)데이터를 도식화하는 것은 변수간 다양한 관계를 재빨리 탐색하는 최상의 방식 중 하나로\n숫자와 문자로 구성된 데이터를 눈으로 일일이 살펴보는 수고 대신\n시각화를 통해 인지부하를 대폭 줄일 수 있기 때문이다.R에는 세가지 주류 도식화 시스템이 존재한다: 기본 도식화 시스템,lattice\n팩키지, ggplot2 팩키지.세가지 도식화 시스템 중에 ggplot2 패키지 즉, 그래프 문법(Grammar Graphics)을\n사용하는 이유는 기본 그래프 문법만 익히면 응용이 무한하여\n원하는 거의 모든 시각화 그래프를 제작할 수 있는 것이 가장 크고,\n고품질 그래프 제작이 가능하기 때문이다.ggplot2는 그래픽 문법(grammar graphics)에 기반했다.\n즉, 모든 그래프도 동일한 구성요소 집합으로 표현된다:\n데이터셋, 좌표 시스템, geoms 집합 – 데이터 점에 대한 시각적 표현.ggplot2를 이해하는 핵심은 그래프를 계층으로 사고하는 것이다:\n포토샵(Photoshop), 일러스트레이터(Illustrator), 잉크스케이프(Inkscape.) 같은\n이미지 편집 프로그램으로 작업하는 것과 동일하지만 이미지 편집 프로그램이\n사람이 모든 것을 조작해야 된다면 그래프 문법을 통한 방식은\n그래프 제작 방식을 명시적으로 표현하면 자동으로 고품질 그래프를 기계가 제작한다는\n점에서 차이가 난다.예제를 가지고 앞서 잡은 개념을 적용해보자.데이터를 시각화하는 것이 목표이기 때문에 입력은 무조건 데이터가 되고\n데이터도 데이터프레임으로 준비하여 ggplot으로 보낸다.\n따라서, 처음으로 수행하는 작업은 ggplot 함수를 호출하는 것이다.\n이 함수가 R에게 새로운 그래프를 생성하고,\nggplot 함수에 전달되는 인자도 해당 그림에 전역 선택옵션(그래프에 있는 모든 계층에 적용)임을 전달한다.\n이와 같이 전역 선택옵션으로 선언하게 되면 다음 계층에 적용되는 인자도 자동으로 전달되기 때문에\n타이핑을 줄이는 효과도 있다.ggplot에 인자를 두개 전달했다.\n먼저, ggplot 그래프에 사용할 데이터가 무엇인지 전달한다.\nggplot(data = gapminder)와 같이 함수에 인자로 넣어도 되지만\n파이프 연산자를 반영하여 코드를 좀더 읽기 좋게 작성하는 것도 가능하다.\n두가지 모두 ggplot() 에 전달되는 데이터가 gapminder데이터프레임이라는 사실은 변하지 않는다.두번째 인자를 aes함수에 전달했는데,\nggplot에게 데이터에 나온 변수를 도식화하는 그래프 시각적 매핑(aes) 속성에 전달한다;\n이번 경우에는 x와 y 위치. 여기서 ggplot에 gapminder데이터프레임 “lifeExp” 칼럼을 x-축에,\n“gdpPercap” 칼럼을 y-축에 도식화한다.\n명시적으로 aes에 칼럼명을 전달(예를 들어, x = gapminder[, “lifeExp”])하지 않은 것에 주목한다.  이것이 가능한 이유는ggplot` 함수가 데이터에 존재하는 칼럼을 식별할만큼 똑똑하기 때문이다!\n이를 통해 중복되는 코딩을 줄여 가독성도 높여 향후 유지보수와 재현가능하게 추적성도 높이는 효과가 있다.데이터프레임을 입력 데이터로 ggplot함수로 보내고 데이터프레임 변수와 시각적 매핑(aes)을 한다고\n도식화가 바로 되는 것은 아니다:ggplot 함수에 데이터를 시각적으로 표현하는 방법도 전달할 필요가 있다.\ngeom 계층을 추가해서 해당 작업이 수행된다.\n본 사례에서, geom_point를 사용했다;\nx와 y 사이 관계를 시각적으로 산점도 형태로 표현하도록 ggplot에게 전달한다.\n즉, 1인당 국민소득(gdpPercap)과 기대수명(lifeExp) 사이 관계를 파악하고자 산점도를\n그리는 것이다.","code":"\nlibrary(tidyverse)\nlibrary(gapminder)\n\ngapminder %>% \n  ggplot( aes(x = gdpPercap, y = lifeExp) ) +\n    geom_point()\ngapminder %>% \n  ggplot( aes(x = gdpPercap, y = lifeExp) )\ngapminder %>% \n  ggplot( aes(x = gdpPercap, y = lifeExp) ) +\n    geom_point()"},{"path":"ggplot-visualization.html","id":"ggplot-visualization-step-02","chapter":"11 .  ggplot 시각화","heading":"11.1 한걸음 더 들어가 보자","text":"기본적인 개념 이해를 바탕으로 그래프 문법에 따라 ggplot 그래프를 제작했다.\n상기예제를 변경해서, 기대수명이 시간에 따라 어떻게 변해왔는지 시각화하는 그림을 생성해보자.\ngapminder 데이터프레임에서 1인당 국민소득(gdpPercap)과 기대수명(lifeExp) 변수를 이전 그래프 제작에\n사용했다면 시간에 따른 기대수명 변화를 파악하기 위해 먼저 gapminder 데이터프레임의\nyear 변수에 주목하고 x-축에 반영하면 해당 문제를 풀 수 있다.이전 그래프에서 aes 함수를 사용해서 geom 산점도로 x 와 y 지점을\n각 점에 대해 표현했다. 변경할 수 있는 또다른 시각적 매핑(aes) 속성은 각 점에 대한 색깔이다.\n앞선 코드를 변경해서 “continent” 대륙별로 각 점에 색을 입혀보자.\n이를 통해 “continent” 칼럼 색상(color)에 적용할 경우 대륙별로 기대했던 추세를\n직접 눈으로 확인하여 기존에 갖고 있던 고정관념과 데이터를 통해 실증할 수도 있다.\n즉, 기대수명은 모든 대륙에서 국가별로 높아지고 있으나 아프리카 국가와 유럽국가들 사이\n간극은 좁혀지고 있지 않다.","code":"\ngapminder %>% \n  ggplot( aes(x = year, y = lifeExp) ) + \n    geom_point()\ngapminder %>% \n  ggplot( aes(x = year, y = lifeExp, color=continent) ) + \n    geom_point()"},{"path":"ggplot-visualization.html","id":"계층layers","chapter":"11 .  ggplot 시각화","heading":"11.2 계층(Layers)","text":"산점도가 아마도 시간에 따라 변하는 정보를 시각화하는데 최선은 아니다.\n시간에 따른 시계열 변화에는 선그래프(line plot)가 적절하다.\nggplot에 점그래프 대신 선그래프(line plot)로 데이터를 시각화한다.geom_point 계층을 추가하는 대신에, geom_line 계층을 추가했다.\naes로 group(혹은 )를 추가하면 자동으로 ggplot이 각 국가를 직선으로 연결해서 도식화한다.하지만, 직선과 점을 함께 시각화하려고 하면 어떨까?\n단순히, 또다른 계층을 그림에 추가하면 된다:각 계층은 이전 계층 위에 도식화됨에 주목한다.\n이번 예제에서, 점이 직선 위에 도식화되었다.\n다음에 도식화한 산출물에서 결과를 확인할 수 있다.시각적 매핑(aes)에서 color=continent가 전역이 아니라 geom_line() 내 로컬로\n이동한 것에도 주목한다. aesthetic인 색상 매핑이 ggplot에 전역으로 설정된 점 선택옵션에서\ngeom_line 계층으로 이동했다. 그래서, 해당 점에는 더이상 적용되지 않는다.\n이제 분명하게 직선 위에 점이 도식화된 것을 확인할 수 있다.지금까지 (색상같은) aesthetic 를 데이터의 변수로 매핑(mapping)해서 사용하는 법을 살펴봤다.\n예를 들어, geom_line(aes(color=continent))을 사용하면, ggplot에서 자동으로 각 대륙별로 다른 색상을 입힌다.\n그런데, 모든 선을 파란색으로 바꾸고자 하면 어떨까? geom_line(aes(color=\"blue\")) 명령어가 동작해야 된다고 생각하지만,\n사실은 그렇지 않다.특정 변수에 대한 매핑을 생성하지 않았기 대문에,\naes() 함수 밖으로 색상을 명세하는 부분을 예를 들어, geom_line(color=\"blue\")와 같이 빼내기만 하면 된다.앞선 예제에서 점과 직선 계층 코딩 순서를 뒤바꾼다. 어떻게 될까요?\n선이 점 위에 올라온다! 이런 특성을 인지하고 염두에 두면 추후 좀더 미련한\n시각화 결과물을 제작할 수 있게 된다.","code":"\ngapminder %>% \n  ggplot(aes(x=year, y=lifeExp, by=country, color=continent)) +\n    geom_line()\ngapminder %>% \n  ggplot( aes(x=year, y=lifeExp, group=country, color=continent) ) +\n    geom_line() + \n    geom_point()\ngapminder %>% \n  ggplot( aes(x=year, y=lifeExp, by=country) ) +\n    geom_line(aes(color=continent)) + \n    geom_point()\ngapminder %>% \n  ggplot( aes(x=year, y=lifeExp, by=country)) +\n    geom_point() + \n    geom_line(aes(color=continent))"},{"path":"ggplot-visualization.html","id":"변환transformations과-통계량statistics","chapter":"11 .  ggplot 시각화","heading":"11.3 변환(Transformations)과 통계량(statistics)","text":"ggplot으로 데이터 위에 통계적 모형을 쉽게 겹치게도 할 수 있다.\n믿을 수 없다면 앞서 제작한 시각화 예제로 예제로 되돌아간다:현재, 일인당 GDP에 일부 심각한 이상점이 있어 점(국가) 사이 내재된 관계를 보기 힘들다.\nscale 척도함수를 사용해서 y-축 척도를 변경한다.\n이것을 통해 데이터 값과 aesthetic 시각값 사이 매핑을 제어한다.\nalpha 함수를 통해 투명도도 조정할 수 있다.\n군집으로 많은 데이터가 모아진 경우 특히 투명도 조절을 유용하다.그래프에 렌더링하기 전에 log10 함수가 gdpPercap 칼럼값에 변환을 시켰다.\n그래서, 각 자리수 10은 변환된 척도에 1씩 증가에 대응된다.\n예를 들어, 1인당 GDP 1,000은 y-축에 3, 10,000은 y-축에 4에 대응된다.\n로그 변환은 x-축에 흩어진 데이터 시각화를 쉽게 도와준다.** aesthetic에 매핑대신 값 설정 **geom_point(alpha = 0.5) 을 사용한 것에 주목한다.\n앞서 언급했듯이, aes() 함수 외부에서 설정된 것은 모든 점에 대해서 지정한 값이 적용되게 된다.\n투명도 지정(alpha)은 이 경우 원하는 바로 문제가 전혀 없다.\n하지만, 다른 aesthetic 설정처럼, alpha 투명도를 데이터의 변수에 매핑시킬 수도 있다.\n예를 들어, 각 대륙별로 다른 투명도를 적용시키고자 하면, geom_point(aes(alpha = continent)) 코딩하는 것도 가능하다.또다른 계층(geom_smooth)을 추가해서 관계를 단순히 적합시킬 수 있다:굵은 선은 geom_smooth 계층에 aesthetic 크기를 설정해서 조정할 수 있다:시각적 매핑(aes) 항목을 명세할 수 있는 방식이 두개 있다.\n바로 앞에서 geom_smooth 함수에 인자로 전달해서 크기에 대한 시각적 매핑 설정을 했다.\n앞에서는 aes() 함수를 사용해서 데이터 변수와 시각적 표현 사이 매핑으로 정의했다.바로 앞 예제에서 점 계층에 나온 점 크기와 색상을 변경해보자.\naes() 함수를 사용하지 않고 특정 색상 예를 들어 오렌지(orange) 색상으로\n변경시키고 함께 크기도 달리한다.한걸음 더 나아가 점(국가)들이 다른 형태(shape)를 갖고\n대륙별로 색상을 달리하는데 대륙별로 추세선을 반영한다.\n이 경우는 색상 인자를 시각적 매핑 함수 aes() 내부로 위치를 조정하여\n인자로 넘긴다.","code":"\ngapminder %>% \n  ggplot(aes(x = gdpPercap, y = lifeExp, color=continent)) +\n    geom_point()\ngapminder %>% \n  ggplot( aes(x = gdpPercap, y = lifeExp) ) +\n    geom_point(alpha = 0.5) + \n    scale_x_log10()\nggplot(data = gapminder, aes(x = gdpPercap, y = lifeExp)) +\n  geom_point() + scale_x_log10() + geom_smooth(method=\"lm\")\ngapminder %>% \n  ggplot( aes(x = gdpPercap, y = lifeExp) ) +\n    geom_point() + \n    scale_x_log10() + \n    geom_smooth(method=\"lm\", size=1.5)\ngapminder %>% \n  ggplot( aes(x = gdpPercap, y = lifeExp) ) +\n    geom_point(size=3, color=\"orange\") + \n    scale_x_log10() + \n    geom_smooth(method=\"lm\", size=1.5)\ngapminder %>% \n  ggplot( aes(x = gdpPercap, y = lifeExp, color = continent) ) +\n    geom_point(size=3, shape=17) + \n    scale_x_log10() + \n    geom_smooth(method=\"lm\", size=1.5)"},{"path":"ggplot-visualization.html","id":"다중-창multi-panel-그림","chapter":"11 .  ggplot 시각화","heading":"11.4 다중-창(Multi-Panel) 그림","text":"앞에서 그래프 하나에 모든 대륙 국가에 대해 시간의 변화에 따른 기대수명 변화를 시각화했다.\n대안으로, 패싯(facet) 창 계층을 추가해서, 그래프를 여러개 창으로 쪼갤 수도 있다:\n“” 혹은 “Z”로 시작하는 국가명을 갖는 나라만 집중해 보자.\n국가가 많다보니 편의상 “” 혹은 “Z”로 시작하는 국가명을 통해\n대략 10개 내외 범주를 갖는 시각화를 하는데 유용한 기법이다.dplyr 패키지 mutate()와 filter() 함수를 조합하여 주어진 문제에 해결할 수 있는\n데이터프레임을 준비하고 이를 facet_wrap() 함수에 넣어 국가별로 연도별\n기대수명을 한눈에 비교할 수 있도록 시각화한다.여기서 str_sub() 함수는 문자를 전문으로 다루는 stringr 패키지의 함수로\n문자열의 일부를 추출하는데 사용했다. 물론 다른 함수나 코드를 통해 해당 문제를\n풀수도 있다. 주어진 문제를 풀 수 있는 가장 직관적이고 간결한 코드 작성을 추천한다.facet_wrap 계층은 “공식(formula)”을 인자로 받는데, (~) 틸드로 표기한다.\ngapminder 데이터셋 국가별 칼럼의 유일한 값 각각에 대해 별도 창을 통해 도식화한다.","code":"\ngapminder %>% \n  ## A,Z 문자 시작 국가명 추출\n  mutate(AZ_country = str_sub(country, start = 1L, end = 1L)) %>% \n  filter(AZ_country %in% c(\"A\", \"Z\")) %>% \n  ## A,Z 문자 시작국가 작은 창 시각화\n  ggplot( aes(x = year, y = lifeExp, color=continent) ) +\n    geom_line() + \n    facet_wrap( ~ country)"},{"path":"ggplot-visualization.html","id":"change-text","chapter":"11 .  ggplot 시각화","heading":"11.5 텍스트 변경하기","text":"고품질 출판에 적합하게 그래프를 깔끔하게 만들려면, 텍스트 요소를 변경할 필요가 있다.\nx-축이 중복되어 난잡하게 보일 수 있고,\ny-축은 데이터프레임 칼럼명이 아닌 영어로 “Life expectancy”, 혹은 “기대수명”으로 적혀있어야\n그래프 가독성을 높일 수 있다.ggplot에서 이 문제도 몇개 다른 계층을 추가함으로써 텍스트를 간단히 변경할 수 있다.\ntheme 계층은 각 축에 대한 텍스트, 전반적인 텍스트 크기를 제어한다.\n축, 그래프 제목, 범례는 labs() 함수를 사용해서 설정하다.\n범례 제목은 aes() 함수에서 명세한 것과 동일한 명칭을 사용한다.\n따라서, 색상 범례 제목은 color = \"대륙\"이 되는 반면에,\n채우기(fill) 범례는 fill = \"대륙\"으로 설정하게 된다.","code":"\ngapminder %>% \n  ## A,Z 문자 시작 국가명 추출\n  mutate(AZ_country = str_sub(country, start = 1L, end = 1L)) %>% \n  filter(AZ_country %in% c(\"A\", \"Z\")) %>% \n  ## A,Z 문자 시작국가 작은 창 시각화\n  ggplot( aes(x = year, y = lifeExp, color=continent) ) +\n    geom_line() + \n    facet_wrap( ~ country) +\n    labs(\n      x = \"Year\",              # x 축 제목\n      y = \"Life expectancy\",   # y 축 제목\n      title = \"국가명 A, Z 시작국가 연도별 기대수명 비교\",   # 그래프 제목\n      color = \"대륙\"      # 범례 제목\n    ) +\n    theme(axis.text.x=element_blank(), \n          axis.ticks.x=element_blank())"},{"path":"ggplot-visualization.html","id":"ggplot-export","chapter":"11 .  ggplot 시각화","heading":"11.6 그래프 내보내기","text":"ggsave() 함수를 사용해서 ggplot으로 생성시킨 그래프를 내보내서 로컬 컴퓨터에 저장할 수 있다.\n고품질 그래픽 산출물을 생성하기 위해서\n그래프 크기와 해상도를 ggsave() 함수의 인자(width, height, dpi)로 넘기면 된다.\n앞서 생성한 그래프를 저장하려면, 먼저 적절한 변수명 예를 들어, lifeExp_plot 변수에 그래프를 할당하고 나서,\nggsave() 함수에 png 형식으로 results 디렉토리에 저장하도록 지정한다.\n(현 작업디렉토리에 results/ 폴더가 생성되어 있어야 한다.)ggsave() 함수에 두가지 멋진 점이 있다.\n첫째는 기본설정값으로 가장 마지막 그래프가 지정되어 있어서,\nplot = 인자를 생략하게 되면, 자동으로 ggplot으로 생성한 마지막 그래프가 저장된다.\n둘째로, 저장되는 그래프 이미지 형식이 파일명으로 전달하는 파일 확장자(예를 들어, .png 혹은 .pdf)에 따라 결정된다.\n필요한 경우, device 인자에 명시적으로 파일 형식을 지정할 수도 있다.지금까지 ggplot2 맛을 보았다. RStudio는 정말 유용한 cheat sheet를 통해서 다른 계층 사용법에 대한\n참고서로 충실한 정보를 제공하고 있고, ggplot2 웹사이트에 추가기능에 대한 상세한 정보가 공개되어 있다.마지막으로, 어떻게 수정을 해야하는지 아무런 생각이 없다면, 구글 검색을 통해서 결국 Stack Overflow 웹사이트에\n재사용 가능한 코드를 통해서 관련된 질문과 답변을 수월히 얻을 수 있다!마지막으로 대륙별로 1인당 GPD 밀도 그래프를 생성해보자.x-축을 변경해서 쭉 펼쳐진 데이터를 좀더 보기좋게 시각화한다.패싯(facet) 계층을 추가해서 연도별로 밀도 그래프를 창에 도식화한다.기존 그래프에 가독성을 높이기 위해 범례 위치를 기본설정인 우측에서 상단으로 이동하고\n1인단 국민소득 숫자도 과학표기법이 아닌 일반 숫자 표기법을 반영하여 가독성을 높였다.\n이외 독자가 더 쉽게 정보를 파악할 수 있도록 필요한 경우 전문분야 지식을 반영하여\n미려한 그래프 제작도 가능하다.","code":"\naz_gapminder <- gapminder %>% \n  ## A,Z 문자 시작 국가명 추출\n  mutate(AZ_country = str_sub(country, start = 1L, end = 1L)) %>% \n  filter(AZ_country %in% c(\"A\", \"Z\"))\n\nlifeExp_plot <- az_gapminder %>% \n  ggplot( aes(x = year, y = lifeExp, color=continent) ) +\n    geom_line() + \n    facet_wrap( ~ country) +\n    labs(\n      x = \"Year\",              # x 축 제목\n      y = \"Life expectancy\",   # y 축 제목\n      title = \"국가명 A, Z 시작국가 연도별 기대수명 비교\",   # 그래프 제목\n      color = \"대륙\"      # 범례 제목\n    ) +\n    theme(axis.text.x=element_blank(), \n          axis.ticks.x=element_blank())\n\nggsave(filename = \"results/lifeExp.png\", plot = lifeExp_plot, width = 12, height = 10, dpi = 300, units = \"cm\")\ngapminder %>% \n  filter(continent != \"Oceania\") %>% ## 호주/뉴질랜드 제외\n  ggplot( aes(x = gdpPercap, fill=continent) ) +\n    geom_density(alpha=0.6) + \n    facet_wrap( ~ year, scales = \"free\") + \n    scale_x_log10( labels = scales::comma ) +\n    labs( x = \"1인당 국민소득\",\n          y = \"분포 밀도\",\n          title = \"대륙별로 1인당 GPD 분표 비교\",\n          fill  = \"대륙: \") +\n    theme(legend.position = \"top\")"},{"path":"ggplot-pattern.html","id":"ggplot-pattern","chapter":"12 .  시각화 패턴","heading":"12 .  시각화 패턴","text":"","code":""},{"path":"ggplot-pattern.html","id":"gghighlight-timeseries","chapter":"12 .  시각화 패턴","heading":"12.1 라벨 붙은 시계열","text":"시계열 데이터를 제작하게 되면 추세를 파악할 수 있지만 결국 그래서 가장 최근 값이 어떻게 되는지 관심이 많다.\n이런 사용자 요구를 맞추는데 시계열 데이터 마지막 시점에 라벨값을 붙이게 되면 가독성도 좋아진다.\n기본적인 작업흐름은 데이터셋에서 가장 최근 관측점을 뽑아서 별도 데이터프레임으로 저장하고\n이를 geom_text() 혹은 geom_text_repel() 함수를 사용해서 해결한다.BLOGR 님이 작성한 Label line ends time series ggplot2 코드를 참조하여 ggplot으로 코드를 작성한다.","code":"\n## 마지막 관측점\norange_ends <- datasets::Orange %>% \n  group_by(Tree) %>% \n  filter(age == max(age)) %>% \n  ungroup()\n\ndatasets::Orange %>% \n  ## 범례와 그래프 순서 맞추기 위해 범주 순서 조정\n  mutate(Tree = fct_reorder(Tree, -circumference) ) %>%\n  ggplot(aes(age, circumference, color = Tree)) +\n    geom_line(size = 2, alpha = .8) +\n    scale_x_continuous(label=scales::comma, limits = c(0, 1600)) +\n    ## 마지막 관측점 라벨과 큰 점 추가\n    geom_text(data = orange_ends, aes(label = circumference, color = NULL), hjust = -0.5,) +\n    geom_point(data = orange_ends, aes(x=age, y= circumference), size = 3.7) +\n    theme_minimal(base_family = \"MaruBuri\") +\n    labs(title = \"오렌지 나무 성장곡선\",\n         subtitle = \"R 내장된 Orange 데이터셋\",\n         x = \"일별 경과 시간\", y = \"직경 (mm)\", \n         caption = \"제작: 한국 R 사용자회\",\n         color = \"나무\")"},{"path":"ggplot-pattern.html","id":"gghighlight-barplot-color","chapter":"12 .  시각화 패턴","heading":"12.2 막대그래프 그룹별 색상","text":"RStudio를 거쳐 IBM에서 근무하고 있는 Alison Presmanes Hill 의 GitHub 저장소에 공개된 TV 시리즈 데이터를 사용해서 막대그래프를 작성할 때 그룹별 색상을 적용하여 가시성을 높인다. TV 시리즈별 색상을 달리할 경우 RColorBrewer 패키지 생상 팔레트를 범주형에 맞춰 각 시리즈별로 가장 잘 구분될 수 있도록 색상을 칠해 시각화를 한다.","code":"\nratings <- read_csv(\"http://bit.ly/cs631-ratings\",\n                    na = c(\"\", \"NA\", \"N/A\"))\n\n# 데이터 준비\nratings_bonanza1 <- ratings %>% \n  mutate(ep_id = row_number(),\n         series = as.factor(series)) %>% \n  select(ep_id, viewers_7day, series)\n\n# 시각화\nbarplot_pal <- RColorBrewer::brewer.pal(n=8, name = \"Accent\")\n\nratings_bonanza1 %>% \n  ggplot(aes(x = ep_id, y = viewers_7day, fill = series)) +\n    geom_col(alpha = .9) + # 막대그래프\n    theme_minimal(base_family = \"MaruBuri\") +\n    theme(legend.position = \"bottom\",\n          text = element_text(family = \"Lato\"),\n          axis.text.x = element_blank(),\n          axis.ticks.x = element_blank(),\n          axis.title.x = element_blank()) + \n    ## 시즌별 다른 색상 팔레트 적용\n    scale_fill_manual(values = barplot_pal) +\n    scale_x_continuous(expand = c(0, 0)) +\n    guides(fill = guide_legend(nrow = 1)) + # 범례 한줄 정렬\n    labs( title = \"8번째 시즌 폭망했음!!\",\n          subtitle= \"전시즌, 회차별 시청자수\",\n          fill = \"시즌\",\n          y    = \"7일 시청자수\") "},{"path":"ggplot-pattern.html","id":"gghighlight-trend-line-label","chapter":"12 .  시각화 패턴","heading":"12.3 추세선 강조 + 라벨","text":"시각화의 백미는 아무래도 대조와 비교를 통해 강한 인상을 주는 것이다.\n앞선 ratings TV 시리즈 시청자 평가 데이터를 대상으로 추세선에 강조를 넣고 라벨 텍스트도 넣어\n하이라이트 강조 그래프를 작성해보자.\ngeom_line()을 두개 포함시켜 강조하고하는 색상을 별도로 지정하고 선굵기도 달리한다.\n라벨도 동일한 방법으로 geom_text()를 두개 포함시켜 강조하고자하는 색상과 글꼴크기도 달리 지정한다.","code":"\nratings %>% \n  mutate(episode = as.factor(episode)) %>% \n  ggplot(aes(x = episode, y = viewers_7day, group = series)) +\n    geom_line(data = filter(ratings, !series == 8), alpha = .25) +\n    ## 기존 그려진 선에 굵은 선과 색상을 달리하여 차별화한다.\n    geom_line(data = filter(ratings, series == 8), color = \"#CF2154\", size = 1.5) +\n    theme_minimal(base_family = \"MaruBuri\") + \n    labs(x = \"에피소드\", y=\"1주일 시청자수\", title=\"여덟번째 스리즈가 문제네!!!\") +\n    geom_text(data = filter(ratings, episode == 1 & series %in% c(1:7)), color = \"gray50\",\n              aes(label = paste0(series, \" 회차 \")), vjust = -1, family = \"MaruBuri\") +\n    ## 8회차 텍스트 반대위치에 크기를 달리하고 글꼴도 달리하여 라벨 추가\n    geom_text(data = filter(ratings, episode == 10 & series == 8), color = \"#CF2154\",\n              aes(label = glue::glue(\"{series} 회차\")), vjust = -1, family = \"Nanum Pen Script\",\n              size = 7)"},{"path":"ggplot-pattern.html","id":"gghighlight-barplot-color","chapter":"12 .  시각화 패턴","heading":"12.4 롤리팝(lolli-pop) 그래프","text":"롤리팝(Lollipop) 사탕 그래프는 막대그래프와 클리블랜드 점그래프를 합성한 것으로 한축에는 연속형, 다른 한축에는 범주형을 두고 사용자의 관심을 점그래프로 집중시키는데 효과적이다. 단순히 막대그래프를 제작하는 것과 비교하여 임팩트있는 시각화를 가능하게 한다.제작순서는 막대그래프 → 점그래프 → 롤리팝 그래프로 뼈대 골격을 만들어 나간다.\n대략 골격이 제작되고 나면 외양과 필요한 경우 값도 텍스트로 넣어 시각화 제품을 완성한다.\n롤리팝 사탕 그래프를 작성할 때 geom_point()를 사용해서 롤리팝 사탕을 제작하고,\ngeom_sgement() 함수를 사용해서 사탕 막대를 그린다. 이때 막대 사탕의 시작과 끝을\n시작은 x, y에 넣어주고 끝은 xend와 yend에 넣어 마무리한다.데이터는 ggplot2에 내장된 midwest 데이터를 사용하자. midwest 데이터셋은\n2000년 미국 중서부 센서스 데이터로 인구통계 조사가 담겨있다.\npercollege 변수는 카운티(우리나라 군에 해당) 별 대학졸업비율을 나타낸다.한발더 나아가, 평균값에서 얼마나 차이가 있느냐를 롤리팝 그래프로 시각화하는 패턴이 많이 사용된다.\n이를 위해서, 앞서와 마찬가지로 15개 카운티를 뽑아내고 평균을 구하고 평균이상, 평균이하에 대한 요인(factor)도 함께 만들어낸다.\n반영한다.","code":"\n# 데이터 -----\n## 롤리팝 사탕 그래프를 위해 상위 15개 군만 추출\nohio_top15 <- ggplot2::midwest %>%\n        filter(state == \"OH\") %>%\n        select(county, percollege) %>%\n        ## 대졸자 비율이 높은 카운티 15개 선정\n        top_n(15, wt = percollege) %>%\n        ## 시각화를 위해 오름차순 정렬\n        arrange(percollege) %>%\n        ## 문자형 자료를 범주형으로 변환\n        mutate(county = factor(county, levels = .$county)) \n\nohio_barplot_g <- ohio_top15 %>% \n  ggplot(aes(county, percollege)) +\n    geom_col(width = 0.5) +\n    coord_flip() +\n    labs(title = \"막대그래프\",\n         y = \"대졸비율(%)\",\n         x = \"\")\n\nohio_dotplot_g <- ohio_top15 %>% \n  ggplot(aes(county, percollege)) +\n    geom_point() +\n    coord_flip() +\n    labs(title = \"점그래프\",\n         y = \"대졸비율(%)\",\n         x = \"\")\n\nohio_lollipop_g <- ohio_top15 %>% \n  ggplot(aes(county, percollege)) +\n    geom_point() +\n    geom_segment(aes(x = county, xend = county, \n                     y = 0, yend = percollege), color = \"grey50\") +\n    coord_flip() +\n    labs(title = \"롤리팝 사탕 그래프\",\n         y = \"대졸비율(%)\",\n         x = \"\")\n\ncowplot::plot_grid(ohio_barplot_g, ohio_dotplot_g, ohio_lollipop_g, nrow=1)\n## 평균기준 대졸비율 비교를 위한 데이터셋 준비\nohio <- midwest %>%\n        filter(state == \"OH\") %>%\n        select(county, percollege) %>%\n        top_n(15, wt=percollege) %>%\n        arrange(percollege) %>%\n        mutate(Avg = mean(percollege, na.rm = TRUE),\n               Above = ifelse(percollege - Avg > 0, TRUE, FALSE),\n               county = factor(county, levels = .$county))\n\n## 시각화 기본 골결 제작\ncomparison_lollipop_g <- ohio %>% \n  ggplot( aes(percollege, county, color = Above) ) +\n        geom_segment(aes(x = Avg, y = county, \n                         xend = percollege, yend = county), color = \"grey50\") +\n        geom_point()\n\n## 외양과 설명을 넣어 가시성을 높임\nohio %>% \n  ggplot( aes(percollege, county, color = Above, label=round(percollege,1)) ) +\n    geom_segment(aes(x = Avg, y = county, \n                     xend = percollege, yend = county), color = \"grey50\") +\n    geom_point(size=7) +\n    annotate(\"text\", x = 27.5, y = \"WOOD\", label = \"평균이상\", color = \"#00BFC4\", size = 5, hjust = -0.1, vjust = 5) +\n    annotate(\"text\", x = 27.5, y = \"WOOD\", label = \"평균이하\", color = \"#F8766D\", size = 5, hjust = +1.1, vjust = -1) +\n    geom_text(color=\"black\", size=3) +\n    theme_minimal(base_family = \"MaruBuri\") +\n    labs(x=\"대졸 비율(%)\", y=\"\",\n         title=\"오하이오주 카운티별 대졸비율 비교\")  +\n    geom_segment(aes(x = 27.5, xend = 27.5 , y = \"WOOD\", yend = \"WARREN\"), size=1,\n                 arrow = arrow(length = unit(0.2,\"cm\")), color = \"#00BFC4\") +\n    geom_segment(aes(x = 27.5, xend = 27.5 , y = \"MONTGOMERY\", yend = \"DELAWARE\"), size=1,\n                 arrow = arrow(length = unit(0.2,\"cm\")), color = \"#F8766D\") +\n    theme(legend.position = \"none\")"},{"path":"ggplot-pattern.html","id":"gghighlight-dumbbel-plot","chapter":"12 .  시각화 패턴","heading":"12.5 아령(dumbbell) 그래프","text":"두시점을 비교하여 전후를 비교한다던가 두 지역을 비교할 때 아령 그래프는 매우 효과적이다.\nTV 시리즈별로 회차를 달리하여 첫번째와 가장 마지막 시청자수를 비교하여 시각화하는데 아령(dumbbell) 그래프가 적절한 예시가 될 것으로 보인다. 이를 위해서 ggplot()에 들어가는 자료형을 미리 준비하고 이에 맞춰 geom_line()과 geom_point()를 결합시켜 시각화한다.","code":"\nratings_dumbbell_df <- ratings %>% \n  select(series, episode, viewers_7day) %>% \n  group_by(series) %>% \n  filter(episode == 1 | episode == max(episode)) %>% \n  mutate(episode = ifelse(episode == 1,\"1회차\", \"최종회\")) %>% \n  ungroup() %>% \n  mutate(series = as.factor(series))\n\n# RColorBrewer::display.brewer.all() 색상\ndumbbell_pal <- RColorBrewer::brewer.pal(n=3, name=\"Set1\")\n\nratings_dumbbell_df %>% \n  ggplot(aes(x = viewers_7day, y = fct_rev(series), color = episode, group = series)) +\n    geom_line(size = .75) +\n    geom_point(size = 2.5) +\n    theme_minimal() +\n    scale_color_manual(values = dumbbell_pal) +\n    labs(title = \"아령 그래프 사례\",\n         subtitle = \"첫번째와 마지막 TV 시리즈를 에피소드별로 비교\",\n         y = \"시즌\", x = \"시청자수 (백만명)\",\n         color = \"회차\") +\n    theme(text = element_text(family = \"MaruBuri\"),\n          legend.position = \"top\")"},{"path":"ggplot-pattern.html","id":"gghighlight-slope-plot","chapter":"12 .  시각화 패턴","heading":"12.6 경사(Slope) 그래프","text":"아령 그래프를 제작한 동일한 데이터를 터프티(tufte) 스타일 경사그래프로 구현하면\n시즌별 첫회와 최종회 시청자수 비교를 좀더 직관적으로 만들 수 있다.ggplot의 기본기능을 활용하여 경사그래프를 시각화하고 강조하고자 하는 시즌을\n색상을 달리하여 표현한다. 이를 통해 1~7번째 시즌은 1회차 시청율은 낮으나 최종회는 높게\n마무리된 것을 알 수 있고, 더불어 시즌이 진행될 수록 1회차 시청율도 높아지고 있었다.\n하지만 8번째 시즌은 다른 시즌과 달리 낮게 시작했고 최종회 시청률도 크게 나아지지 않은 것을\n한눈에 파악할 수 있다.경사그래프를 제작하고는 싶으나 전반적으로 시간이 더 필요하신 분을 위해\nslopegraph 패키지가 있다.slopegraph는 Base 그래픽을 기본으로 삼고 있어 자료구조도 rownames를 갖는 전통적인 데이터프레임이다.\n기본 Base 그래픽을 염두에 두고 상기 TV 연속물 경사그래프를 다음과 같이 작성할 수 있다.slopegraph() 함수 대신 ggslopegraph() 함수를 사용하게 되면 ggplot()으로도 시각화를 할 수 있다.\nslopegraph() 함수는 자료구조가 직관적이라 처음 시각화를 하는 분에게 적절한 듯 보인다.\n따라서, 앞서 ggplot 기반 경사그래프를 제작하고자 하는 경우 ggslopegraph()을 통해서도 ggplot 나머지 기능을 그대로 적용 가능하다.","code":"\nratings_dumbbell_df %>% \n  ggplot(aes(x = episode, y = viewers_7day, group = series)) +\n    geom_point(data = filter(ratings_dumbbell_df, !series == 8), alpha = .25) +\n    geom_point(data = filter(ratings_dumbbell_df, series == 8), color = \"#CF2154\") +\n    geom_line(data = filter(ratings_dumbbell_df, !series == 8), alpha = .25) +\n    geom_line(data = filter(ratings_dumbbell_df, series == 8),color = \"#CF2154\") +\n    theme_minimal(base_family = \"MaruBuri\") +\n    labs(title = \"경사그래프(Slopegraph) 사례\", x=\"에피소드\", y=\"주별 시청자수 (단위: 백만)\") +\n    ## 8번째 시즌\n    geom_text(data = filter(ratings_dumbbell_df, episode == \"최종회\" & series %in% c(1:7)), color = \"gray\",\n              aes(label = series), vjust = -1, family = \"Nanum Pen Script\", hjust = .5) +\n    geom_text(data = filter(ratings_dumbbell_df, episode == \"최종회\" & series == 8), color = \"#CF2154\",\n              aes(label = paste0(series, \" 시즌\")), vjust = -1, family = \"Nanum Pen Script\", size=5) +\n    ## 1~7번째 시즌\n    geom_text(data = filter(ratings_dumbbell_df, episode == \"1회차\" & series %in% c(1:7)), color = \"gray50\",\n              aes(label = paste0(series, \" 시즌\")), family = \"MaruBuri\", hjust = 1.2) \n# devtools::install_github(\"leeper/slopegraph\")\nlibrary(slopegraph)\n\nseries_cols <- c(rep(\"darkgray\", 7), \"red\")\n\nratings_dumbbell_df %>% \n  spread(episode, viewers_7day) %>% \n  as.data.frame() %>% \n  column_to_rownames(var=\"series\") %>% \n  slopegraph(., col.lines = series_cols, col.lab = series_cols, \n            cex.lab = 1.5, cex.num = 1.0,\n            xlim = c(-0.5, 3.5), \n            xlabels = c('첫회','최종회'))\nratings_dumbbell_df %>% \n  pivot_wider(names_from = episode, values_from = viewers_7day) %>% \n  as.data.frame() %>% \n  column_to_rownames(var=\"series\") %>% \n  ggslopegraph(offset.x = 0.06, yrev = FALSE,\n               col.lines = series_cols, col.lab = series_cols) +\n    theme_minimal(base_family = \"NanumGothic\") +\n    labs(title = \"경사그래프 사례 - ggplot\")"},{"path":"사례.html","id":"사례","chapter":"사례","heading":"사례","text":"","code":""},{"path":"case-journalism.html","id":"case-journalism","chapter":"13 .  데이터 저널리즘","heading":"13 .  데이터 저널리즘","text":"오마이뉴스 제20대 대통령 선거, 사전투표 역사를 새로 쓰다 - 마의 30%대 넘긴 사전투표율 데이터 저널리즘 기사에 포함된 시각화 객체를 작성해보자. 제20대 대통령선거에서 사전투표율이 30%를 넘긴 사실과 이를 한눈에 사전투표율 변화를 제19대 대통령선거와 비교하여 2일에 걸쳐 실시된 사전투표를 그래프 우측에 사전투표율 차이를 꼼꼼히 작성한 것이 이채로운 기사다.이 기사를 작성하기 위해 공공데이터를 크롤링하여 정제하는 과정을 거치고 이를 다양한 시각화 방법론 중에서 독자에게 객관적인 사실을 읽기 편하고 정보를 제대로 제공할 수 있는 형태로 전달하도록 ggplot을 사용해서 제작했다.","code":""},{"path":"case-journalism.html","id":"case-study-crawling","chapter":"13 .  데이터 저널리즘","heading":"13.1 크롤링","text":"먼저 중앙선거관리위원회 선거통계시스템 웹사이트에서 제19대\n대통령선거 사전투표율 데이터를 시도별로 크롤링한다. 오마이뉴스 기자가 제19대와 제20대를 비교하여 5년간의 사전투표율 변화를 통해 유권자의 표심과 사회적 변화를 담아내고자 두 시점 2017년과 2022년을 각각 가져온다.","code":""},{"path":"case-journalism.html","id":"case-study-19th","chapter":"13 .  데이터 저널리즘","heading":"13.1.1 제19대 대통령 선거","text":"중앙선관위 선거통계시스템에서 시도별로 사전투표율 데이터를 조회하도록 했기 때문에 각 시도별로 반복이 필요하기 때문에 함수로 작성해서 특정 시도를 기준으로 테스트 작업을 수행한다.","code":"\n# 0. 패키지 ----------------\nlibrary(tidyverse)\nlibrary(rvest)\nlibrary(httr)\nlibrary(lubridate)\n\n## 크롤링 함수 \n\nget_early_voting_data <- function(sido_code = \"1100\", date_code = \"1\") {\n  \n  cat(\"\\n------------------------------\\n\", sido_code, \":\", date_code, \"\\n\")\n  \n  nec_url <- glue::glue(\"http://info.nec.go.kr/electioninfo/electionInfo_report.xhtml?\",\n                      \"electionId=0000000000\",\n                      \"&requestURI=%2FWEB-INF%2Fjsp%2Felectioninfo%2F0000000000%2Fvc%2Fvcap01.jsp\",\n                      \"&topMenuId=VC\",\n                      \"&secondMenuId=VCAP01\",\n                      \"&menuId=VCAP01\",\n                      \"&statementId=VCAP01_%234\",\n                      \"&oldElectionType=1\",\n                      \"&electionType=1\",\n                      \"&electionName=20170509\",\n                      \"&cityCode={sido_code}\",\n                      \"&dateCode={date_code}\")\n\n  Sys.setlocale(\"LC_ALL\", \"C\")\n  \n  nec_html <- read_html(nec_url)\n  \n  nec_raw <- nec_html %>% \n    html_element(css = '#table01') %>% \n    html_table(fill = TRUE)\n  \n  Sys.setlocale(\"LC_ALL\", \"Korean\")\n  \n  nec_colnames <- nec_raw %>% \n    janitor::clean_names(ascii = FALSE) %>% \n    slice(1) %>% \n    unlist() %>% \n    as.character() %>% \n    dput()\n  \n  nec_tbl <- nec_raw %>% \n    janitor::clean_names(ascii = FALSE) %>% \n    slice(2:n()) %>% \n    set_names(nec_colnames) %>% \n    pivot_longer(`7시`:`18시`, names_to = \"시간\", values_to = \"값\") %>% \n    mutate(구분 = ifelse(str_detect(값, \"%\"), \"투표율\", \"투표자수\")) %>% \n    pivot_wider(names_from = 구분, values_from = 값)\n  \n  nec_tbl\n\n}\n\n# get_early_voting_data(\"4900\", \"2\") # 함수테스트"},{"path":"case-journalism.html","id":"case-19th-crawling","chapter":"13 .  데이터 저널리즘","heading":"13.1.2 데이터 긁어오기","text":"앞서 작성한 함수를 시도 및 구시군별 크롤링하여 데이터프레임으로 저장한다.\n특이한 점은 map2 함수형 프로그래밍 기법을 적용하여 코드를 for문 없이\n간결하게 작성했다.","code":"\npresid_sigungu_code_2017 <- read_csv(\"data/presid_sigungu_code_2017.csv\")\n\nearly_voting_code <- presid_sigungu_code_2017 %>% \n  group_by(시도코드, 시도명) %>% \n  summarise(n = n()) %>% \n  ungroup() %>% \n  select(-n)\n\nearly_voting_2017_raw <- early_voting_code %>% \n  mutate(사전투표일 = rep(list(c(1, 2)), n())) %>% \n  unnest(사전투표일) %>% \n  mutate(data = map2(시도코드, 사전투표일, get_early_voting_data))"},{"path":"case-journalism.html","id":"case-19th-cleaning","chapter":"13 .  데이터 저널리즘","heading":"13.1.3 데이터 정제","text":"제19대 대통령 선거 구시구별 사전투표일 누적투표수를 시각화 가능한 형태로 저장시킨다.","code":"\nearly_voting_2017_tbl <- early_voting_2017_raw %>% \n  unnest(data, names_repair = \"unique\")  %>% \n  janitor::clean_names(ascii = FALSE) %>% \n  set_names(c(\"시도코드\", \"시도명_2\", \"사전투표일\", \"구시군명\", \"선거인수\", \n              \"시간\", \"투표자수\", \"투표율\", \"시도명_9\")) %>% ## 변수명 R4.2 버그 \n  rename(시도명 = 시도명_2) %>% \n  mutate(구시군명 = ifelse(is.na(시도명_9), 구시군명, 시도명_9)) %>% \n  select(-시도코드, -시도명_9) \n\nearly_voting_2017_order <- early_voting_2017_tbl %>% \n  select(시도명, 구시군명, 사전투표일, 시간, 선거인수, 투표자수) %>% \n  filter(구시군명 != \"합계\") %>% \n  pivot_wider(names_from = 사전투표일, values_from = 투표자수) %>% \n  mutate(across(선거인수:`2`, parse_number )) %>% \n  group_by(시도명, 구시군명) %>% \n  mutate(누적투표수 = max(`1`) + `2`)  %>% \n  ungroup() %>% \n  select(-`2`) %>% \n  pivot_longer(`1`:누적투표수, names_to = \"사전투표일\", values_to = \"누적투표수\") %>% \n  mutate(사전투표일 = ifelse(사전투표일 == \"누적투표수\", \"2일\", \"1일\")) %>% \n  mutate(시간순서 = glue::glue(\"{사전투표일}-{시간}\")) %>% \n  arrange(시도명, 구시군명, 시간순서) \n\nearly_voting_2017 <- early_voting_2017_order %>% \n  mutate(사전투표율 = 누적투표수 / 선거인수) %>% \n  mutate(선거구분 = \"제19대\") %>% \n  relocate(선거구분, .before = 시도명)\n\nearly_voting_2017 %>% \n  write_rds(\"data/early_voting_2017.rds\")"},{"path":"case-journalism.html","id":"case-20th","chapter":"13 .  데이터 저널리즘","heading":"13.2 제20대 대통령 선거","text":"제20대 대통령선거 사전투표율 데이터도 제19대 대통령선거와 동일한 방식으로\n크롤링한다.","code":""},{"path":"case-journalism.html","id":"case-20th-crawling-function","chapter":"13 .  데이터 저널리즘","heading":"13.2.1 크롤링 함수","text":"제19대와 달리 제20대는 데이터 제공방식에 차이가 있어 크롤링함수를 이에 맞춰\n작성하여 시도별로 크롤링할 수 있는 함수를 제작한다.","code":"\nget_early_voting_data_latest <- function(sido_code = \"1100\", date_code = \"1\", time_code = \"07\") {\n  \n  cat(\"\\n------------------------------\\n\", sido_code, \":\", date_code, \":\", time_code, \"\\n\")\n  \n  nec_url <- glue::glue(\"http://info.nec.go.kr/electioninfo/electionInfo_report.xhtml?\",\n                      \"electionId=0020220309\",\n                      \"&requestURI=%2FWEB-INF%2Fjsp%2Felectioninfo%2F0020220309%2Fvc%2Fvcap01.jsp\",\n                      \"&topMenuId=VC\",\n                      \"&secondMenuId=VCAP01\",\n                      \"&menuId=VCAP01\",\n                      \"&statementId=VCAP01_%232\",\n                      \"&cityCode={sido_code}\",\n                      \"&dateCode={date_code}\",\n                      \"&timeCode={time_code}\")\n  \n  Sys.setlocale(\"LC_ALL\", \"C\")\n  \n  nec_html <- read_html(nec_url)\n  \n  nec_raw <- nec_html %>% \n    html_element(css = '#table01') %>% \n    html_table(fill = TRUE)\n  \n  Sys.setlocale(\"LC_ALL\", \"Korean\")\n  \n  nec_tbl <- nec_raw %>% \n    set_names(c(\"구시군명\", \"선거인수\", \"사전투표자수\", \"사전투표율\"))\n  \n  nec_tbl\n\n}\n\n# get_early_voting_data_latest(\"4900\", \"2\", \"17\")"},{"path":"case-journalism.html","id":"case-20th-crawling","chapter":"13 .  데이터 저널리즘","heading":"13.2.2 데이터 긁어오기","text":"크로링함수가 완성되었다면 시도코드와 사전투표일, 사전투표시간을 달리하여\n함수형프로그래밍 기법을 적용하여 간결한 크롤링함수를 작성한다.","code":"\nearly_voting_2022_raw <- early_voting_code %>% \n  mutate(사전투표일 = rep(list(c(1, 2)), n())) %>% \n  unnest(사전투표일) %>% \n  mutate(사전투표시간 = rep(list( c(7:18)), 34 )) %>% \n  unnest(사전투표시간) %>% \n  mutate(사전투표시간 = as.character(사전투표시간) %>% str_pad(., 2, \"left\", pad = \"0\")) %>% \n  mutate(data = pmap(list(시도코드, 사전투표일, 사전투표시간), get_early_voting_data_latest))\n\n# early_voting_2022_raw"},{"path":"case-journalism.html","id":"case-20th-cleaning","chapter":"13 .  데이터 저널리즘","heading":"13.2.3 데이터 정제","text":"제20대 대통령 선거 구시구별 사전투표일 누적투표수를 시각화 가능한 형태로 저장시킨다.","code":"\nearly_voting_2022_tbl <- early_voting_2022_raw %>% \n  mutate(data = map(data, ~.x %>% mutate_all(., as.character ) )) %>%\n  unnest(data, names_repair = \"unique\") %>% \n  mutate(across(선거인수:사전투표율, parse_number))\n\nearly_voting_2022_order <- early_voting_2022_tbl %>% \n  filter(구시군명 != \"합계\") %>% \n  select(시도명, 구시군명, 사전투표일, 시간=사전투표시간, 선거인수, 투표자수=사전투표자수) %>% \n  pivot_wider(names_from=사전투표일, values_from = 투표자수) %>% \n  group_by(시도명, 구시군명) %>% \n  mutate(누적투표수 = max(`1`) + `2`)  %>% \n  ungroup() %>% \n  select(-`2`) %>% \n  pivot_longer(`1`:누적투표수, names_to = \"사전투표일\", values_to = \"누적투표수\") %>% \n  mutate(사전투표일 = ifelse(사전투표일 == \"누적투표수\", \"2일\", \"1일\")) %>% \n  mutate(시간순서 = glue::glue(\"{사전투표일}-{시간}\")) %>% \n  arrange(시도명, 구시군명, 시간순서) \n\nearly_voting_2022 <- early_voting_2022_order %>% \n  mutate(사전투표율 = 누적투표수 / 선거인수) %>% \n  mutate(선거구분 = \"제20대\") %>% \n  relocate(선거구분, .before = 시도명) %>% \n  filter(구시군명 != \"합계\") %>% \n  mutate(시간 = as.numeric(시간)) %>% \n  mutate(시간 = glue::glue('{str_pad(시간, 2, \"left\", \"0\")}시'))\n\nearly_voting_2022 %>% \n  write_rds(\"data/early_voting_2022.rds\")"},{"path":"case-journalism.html","id":"case-19th-20th","chapter":"13 .  데이터 저널리즘","heading":"13.3 결합 : 19대 + 20대","text":"앞서 크로링한 19대와 20대 대통령선거 사전투표 구시군별 시간대별 데이터를\n데이터프레임으로 결합하여 시각화를 준비한다.","code":"\nearly_voting_2022 <-  \n  read_rds(\"data/early_voting_2022.rds\")\n\nearly_voting_2017 <-  \n  read_rds(\"data/early_voting_2017.rds\")\n\nearly_voting <- bind_rows(early_voting_2017, early_voting_2022)\n\n# early_voting"},{"path":"case-journalism.html","id":"early-voting-dataframe","chapter":"13 .  데이터 저널리즘","heading":"13.4 데이터프레임","text":"시간대별로 제19대와 제20대 대통령선거를 비교하여 시각화하기 위해 ggplot에 입력값인\n데이터프레임에 필요한 변수작업을 사전 준비하여 시각화에 집중할 수 있도록 작업내용을\n구분해둔다.","code":"\nearly_voting_timeline <- early_voting %>% \n  group_by(선거구분, 시간순서) %>% \n  summarise(선거인수 = sum(선거인수),\n            사전투표수 = sum(누적투표수)) %>% \n  ungroup() %>% \n  mutate(사전투표율 = 사전투표수 / 선거인수) %>% \n  ## 시간순서 맞춤 \n  separate(시간순서, into = c(\"일\", \"시간\"), sep = \"-\") %>% \n  mutate(across(일:시간, parse_number)) %>% \n  mutate(시간 = str_pad(시간, 2, \"left\", \"0\")) %>% \n  mutate(시간순서 = glue::glue(\"{일}일-{시간}시\")) %>% \n  select(선거구분, 시간순서, 사전투표율) %>% \n  ## ggalt::geom_dumbbell\n  pivot_wider(names_from = 선거구분, values_from = 사전투표율) %>% \n  mutate(구분 = ifelse(str_detect(시간순서, \"1일\"), \"첫째날\", \"둘째날\")) "},{"path":"case-journalism.html","id":"timeline-viz-diff","chapter":"13 .  데이터 저널리즘","heading":"13.5 시각화","text":"뉴스기사에 바로 사용할 수 있는 고품질 ggplot 객체를 작성하여 png 파일로\n작성하여 로컬 파일로 내보낸다. 기본 개념은 시간에 대한 순서를 정렬하여 맞추고\n두선거를 아령그래프를 주된 시각화기법을 두고 작성한 후 독자가 큰 흐름을 읽을 수\n있게 만들고 마지막으로 우측에 20대 대선과 19대 대선 시간대별 투표율 차이를\n계산하여 한번에 필요한 모든 정보를 독자가 얻을 수 있도록 제작한다.제19대 대선과 비교한 시간대별 사전투표 투표율 추이","code":"\nlibrary(ggalt)\n\nearly_voting_timeline_diff_g <- early_voting_timeline %>% \n  mutate(차이 = 제20대 - 제19대) %>% \n  ggplot(aes(y = 시간순서, x = 제19대, xend = 제20대)) +\n     geom_dumbbell(aes(color = 구분), size=3, colour_x = \"red\", colour_xend = \"blue\",\n                dot_guide=TRUE, dot_guide_size=0.25) +\n    theme_classic(15, base_family = \"NanumBarunPen\") +\n    theme(legend.position = \"top\",\n          legend.title=element_text(size=15), \n          legend.text=element_text(size=13),\n          strip.text.x = element_text(size = rel(1.3), colour = \"black\", family = \"NanumMyeongjo\", face=\"bold\"),\n          axis.text.y = element_text(size = rel(1.5), colour = \"gray35\", family = \"NanumBarunpen\", face=\"bold\"),\n          axis.text.x = element_text(size = rel(1.3), colour = \"black\", family = \"NanumBarunpen\", face=\"bold\"),\n          strip.background=element_rect(fill=\"gray95\"),\n          plot.title=element_text(size=25, face=\"bold\", family = \"NanumBarunpen\"),\n          plot.subtitle=element_text(face=\"bold\", size=13, colour=\"grey10\", family = \"NanumBarunpen\"),\n          plot.tag.position = c(0.91, 0.93))  +\n    labs(x=\"\",\n         y=\"\",\n         title = \"제19, 20대 대통령선거 사전투표율 시간대별 비교\",\n         caption = \"데이터 출처: 중앙선거관리위원회 선거통계시스템\",\n         tag = \"투표율 차이\") +\n    scale_x_continuous(labels = scales::percent, limits = c(0, 0.45)) +\n    scale_color_manual(values = c(\n      \"제19대\" = \"red\",\n      \"제20대\" = \"blue\",\n      \"첫째날\" = \"gray50\",\n      \"둘째날\" = \"black\")) + \n     geom_text_repel(aes(x = 제19대, label = glue::glue(\"{scales::percent(제19대, accuracy = 0.1)}\")), hjust = 1.5) +\n     geom_text_repel(aes(x = 제20대, label = glue::glue(\"{scales::percent(제20대, accuracy = 0.1)}\")), hjust = -0.5)  +\n     guides(colour = guide_legend(nrow = 1)) +\n     geom_rect(aes(xmin=.4, xmax=.45, ymin=-Inf, ymax=Inf), fill=\"gray90\") +\n     geom_text(aes(label=scales::percent(차이, accuracy = 0.1), y=시간순서, x=.425), fontface=\"bold\", size=5, family=\"NanumBarunPen\") \n\nearly_voting_timeline_diff_g\n\nragg::agg_png(glue::glue(\"assets/images/early_voting_timeline_diff_g.png\"), width = 297, height = 210, units = \"mm\", res = 600)\nearly_voting_timeline_diff_g\ndev.off()"},{"path":"case-worldcup.html","id":"case-worldcup","chapter":"14 .  러시아 월드컵","heading":"14 .  러시아 월드컵","text":"","code":""},{"path":"case-worldcup.html","id":"russia-2018-worldcup","chapter":"14 .  러시아 월드컵","heading":"14.1 독일전 영상기록","text":"러시아 월드컵 예선 마지막 독일과의 경기는 2패로 16강 탈락이 확정되었지만, 독일을 2-0으로 물리치는 감동적인 경기였다. 그럼에도 불구하고 인터넷 상에 남아 있는 영상기록은 많지 않고 SBS Sports 온라인뉴스팀 “대한민국 VS 독일 후반 하이라이트…김영권-손흥민 골”에서 그나마 고화질 동영상 기록을 제공하고 있다. Tokyo R에서 Ryo Nakagawara 발표했던 것에 영감을 받아 독일과 월드컵 최종예선 데이터를 시각화하여 기록해서 남겨두고자 한국알사용자회에서 기여한 것이다. 9 10 11","code":""},{"path":"case-worldcup.html","id":"russia-2018-worldcup-germany","chapter":"14 .  러시아 월드컵","heading":"14.2 정적 시각화","text":"스포츠를 데이터를 통해 이해하는 첫걸음은 아마도 정적 시각화를 먼저 실행하는 것이다.\n이를 위해서 먼저 해당 기록을 남기고자 하는 아이디어가 생기거나 다른 프로젝트나\n뉴슬 통해 영감을 얻게 되면 공공데이터가 존재하여 해당 아이디어를\n시각화할 수 있는지 가늠하는 것이 시작이다.","code":""},{"path":"case-worldcup.html","id":"russia-2018-worldcup-germany-player","chapter":"14 .  러시아 월드컵","heading":"14.2.1 월드컵 참가선수 명단","text":"러시아 월드컵에 참가한 선수명단은 위키 - 2018년_FIFA_월드컵_선수_명단 웹페이지에서 확인이 가능하다. 이를 위해서 먼저 rvest 팩키지를 활용하여 정적 웹페이지를 긁어와서 데이터 정제작업을 거처 월드컵 참가 선수 명단을 확정한다.최종 시각화에 필요한 패키지를 설치한다. ggsoccer는 CRAN에도 등록되어 있어 install.packages(\"ggsoccer\") 명령어나 devtools::install_github(\"torvaney/ggsoccer\") 명령어로 설치한다.\n2년전 초창기에는 GitHub 저장소에 공개되었고 이후 안정화를 거쳐 CRAN에 정식 등록되었다. 그밖에도 웹크롤링에 필요한 rvest 패키지와 애니메이션 제작에 필요한 gganimate, tweenr 패키지를 설치한다. ggimage 패키지는 명칭에도 나오지만 ggplot에 이모티콘, 아이콘, 그림 등을 넣을 수 있게 해주는 패키지다.위키페이지에서 러시아 월드컵에 출전한 선수 주요선수를 득점 기준으로 10명 추려보자.","code":"\n# 0. 환경설정 ------\nlibrary(tidyverse)\nlibrary(rvest)\nlibrary(extrafont)\nloadfonts()\n# devtools::install_github(\"torvaney/ggsoccer\")\nlibrary(ggsoccer)  \nlibrary(tweenr)    \nlibrary(gganimate) \nlibrary(ggimage)   \n\n\n# 1. 데이터 ------\n## 1.1. 월드컵 출전 선수 데이터 -----\nSys.setlocale(\"LC_ALL\", \"C\")\n\nworld_url <- \"https://ko.wikipedia.org/wiki/2018년_FIFA_월드컵_선수_명단\"\n\nplayer_dat <- world_url %>% \n    read_html() %>%\n    html_nodes(xpath='//*[@id=\"mw-content-text\"]/div/table[24]/tbody/tr/td/table') %>% \n    html_table(fill=TRUE) %>% \n    .[[1]]\n \nSys.setlocale(\"LC_ALL\", \"Korean\")\n\nplayer_df <- player_dat %>% \n    janitor::clean_names(ascii = FALSE) %>% \n    mutate(주장여부 = ifelse(str_detect(`선수`, \"\\\\(\"), \"주장\", \"선수\")) %>% \n    mutate(`선수` = str_sub(`선수`, 1, 3))\n\n\nplayer_df %>% \n  arrange(desc(득점)) %>% \n  slice_head(n=10)"},{"path":"case-worldcup.html","id":"출전선수-명단","chapter":"14 .  러시아 월드컵","heading":"14.2.2 출전선수 명단","text":"러시아 월드컵 선수명단에 포함되었다고 독일전에 출전한 것은 아니다.\n러시아 월드컵 마지막 경기여서 앞선 경기에서 주전이였으나 부상, 경기력 부족으로 교체된 선수도 있기 때문에\n실제 독일전에 출전한 선수가 중요하다.\n독일전은 2018-08-27 예선전이 열렸으며 골키퍼 조현우를 비롯한 선발선수명단이 각 포지션별로 발표되었다.골키퍼: 조현우수비: 이용 윤영선 김영권 홍철미드필드: 이재성 정우영 장현수 문선민공격: 구자철 손흥민Soccer event logger를 활용하여 각 선수별 위치를 축구경기장에 클릭하여 좌표를 얻은 후에 선수명을 수작업을 붙여 놓고 이를 ggsoccer 팩키지 annotate_pitch(), theme_pitch() 함수를 사용해서 시각화한다.","code":"\n# 2. 선발 라인업 ------\n\nlineup_df <- tribble(\n    ~x, ~y, ~name,\n9.035, 50.00, \"조현우\",\n24.46, 90.78, \"이용\",\n19.10, 66.05, \"운영선\",\n19.10, 30.52, \"김영권\",\n25.17,  5.52, \"홍철\",\n46.60, 91.57, \"이재성\",\n45.89, 66.05, \"정우영\",\n45.53, 30.42, \"장현수\",\n43.39,  5.52, \"문선민\",\n71.60, 30.26, \"구자철\",\n72.67, 64.73, \"손흥민\")\n\nlineup_df %>% \n  ggplot( aes(x = x, y = y) ) +\n    annotate_pitch() +\n    theme_pitch(aspect_ratio = NULL) +\n    coord_flip() +\n    geom_point( size = 1.5 ) +\n    geom_text( aes(label = name), family=\"NanumGothic\",\n               vjust = 1.5, color = \"blue\")"},{"path":"case-worldcup.html","id":"russia-2018-worldcup-germany-goal","chapter":"14 .  러시아 월드컵","heading":"14.2.3 독일전 골모음","text":"정규 경기시간이 모두 소진된 후에 추가시간이 6분 주워졌고, 추가시간 2분 손흥민의 코너킥이 김영권에 이어지면서 독일전 첫골이 완성되었다. 축구장 골의 움직임은 ball_df 데이터프레임에 2차원 평면이라 , to로 x, y 각각 데이터화시킨다. 축구선수의 위치는 first_player_df 데이터프레임의 첫번째 골에 관여한 선수 위치를 담아낸다.\n선수의 위치는 geom_point(), 공의 움직임은 geom_segment()로 나타내고 첫번째 골의 이동에 집중할 수 있도록 관련된 부분을 정리하고 점위에 텍스트를 추가하여 선수명을 명확히 한다.독일전 두번째 골은 연장 추가시간 막판 골키퍼까지 나와 만회골을 위해 혼신을 다하던 순간, 주세종이 골을 뽑아내고 이를 손흥민에 연결하여 여유있게 골을 골망에 넣어 두번째골이 완성되었다. 앞선방법과 동일하게 두번째 골도 공의 위치와 선수를 데이터프레임에 담아내고 ggplot으로 시각화한다.","code":"\n# 1. 첫번째 골 데이터 ------\n\nball_df <- tribble(~from_x, ~from_y, ~to_x, ~to_y, \n                      0,    100,   6.78, 63.94,\n                      6.78, 63.94, 7.5,  56.84,\n                      7.5,  56.84, 4.64, 38.94,\n                      4.64, 38.94, -0.53,47.36)\n\nfirst_player_df <- tribble(~x, ~y, ~name, \n                   0,    100,   \"손흥민\",\n                   6.78, 63.94, \"이승우\",\n                   7.5,  56.84, \"윤영선\",\n                   4.64, 38.94, \"김영권\")\n\nball_df %>% \n  ggplot() +\n    annotate_pitch() +\n    geom_point(aes(x=from_x, y=from_y, size=1.5, color=\"red\")) +  \n    geom_point(aes(x=to_x, y=to_y, size=1.5, color=\"red\")) +\n    geom_segment(aes(x = from_x, y = from_y, xend = to_x, yend = to_y),\n                 arrow = arrow(length = unit(0.25, \"cm\"),\n                               type = \"closed\")) +\n    theme_pitch() +\n    coord_flip() +\n    xlim(-10, 51) +\n    ylim(-15, 101) +\n    labs(title=\"한국과 독일 월드컵 예선\", \n         subtitle=\"김영권 첫골(90+2)\") +\n    theme(legend.position = \"none\") +\n    geom_text(data=first_player_df, \n        aes(x = x, y = y, label = name, family=c(\"NanumGothic\")),\n        vjust = -1.5, color = \"blue\")\n# 2. 두번째 골 데이터 ------\n\nsecond_ball_df <- tribble(~from_x, ~from_y, ~to_x, ~to_y, \n                   69.28, 15.52, 75.89, 22.89,\n                   75.89, 22.89, 24.28, 62.89,\n                   24.28, 62.89, 2.85, 60.52,\n                   2.85, 60.52, -1.07, 46.31)\n\nsecond_player_df <- tribble(~x, ~y, ~name, \n                           69.28, 15.52, \"주세종\",\n                           24.28, 62.89, \"손흥민\")\n\nsecond_ball_df %>% \n  ggplot() +\n    annotate_pitch() +\n    geom_point(aes(x=from_x, y=from_y, size=1.5, color=\"red\")) +\n    geom_point(aes(x=to_x, y=to_y, size=1.5, color=\"red\")) +\n    geom_segment(aes(x = from_x, y = from_y, xend = to_x, yend = to_y),\n                 arrow = arrow(length = unit(0.25, \"cm\"),\n                               type = \"closed\")) +\n    theme_pitch() +\n    coord_flip() +\n    xlim(-10, 101) +\n    ylim(-15, 101) +\n    labs(title=\"한국과 독일 월드컵 예선\", \n         subtitle=\"손흥민 두번째골(90+6)\") +\n    theme(legend.position = \"none\") +\n    geom_text(data=second_player_df, \n              aes(x = x, y = y, label = name, family=c(\"NanumGothic\")),\n              vjust = -1.5, color = \"blue\")"},{"path":"case-worldcup.html","id":"russia-2018-worldcup-germany-ani","chapter":"14 .  러시아 월드컵","heading":"14.3 동적 시각화","text":"ggplot을 활용한 동적 시각화는 기본적으로 정적 시각화 ggplot 그래프를 생성하고 나서 이를\n애니메이션을 원하면 gganimate, 인터랙티브 그래프를 원하면 plotly 패키지에 연결시키는 것이 일반적이다.선수의 위치와 골의 이동경로를 설정하고 time 순서를 지정한다. 그리고 나서, gganimate 팩키지 transition_states() 함수를 사용해서 득점장면 애니메이션을 생성시킨다.","code":""},{"path":"case-worldcup.html","id":"russia-2018-worldcup-germany-player-first","chapter":"14 .  러시아 월드컵","heading":"14.3.1 김영권 첫번째 골","text":"독일전 첫번째 골의 경우 손흥민 코너킥으로 선수의 움직임이 크지 않은 상태에서 공이 손흥민 → 이승우 → 윤영선 → 김영권으로 연결되며 골로 연결된 경우다. 따라서 골의 움직임만 time을 주어 이동시키면 애니메이션을 간단히 제작할 수 있다.러시아 월드컵 독일전 첫번째 골","code":"\n# 1. 첫번째 골 데이터 ------\n\nfirst_ball_df <- tribble(~x,      ~y,  ~time,\n                         0,      100,   1,\n                         6.78, 67.94,   2,\n                         7.5,  56.84,   3,\n                         4.64, 38.94,   4,\n                         -0.8,  47,   5)\n\nfirst_player_df <- tribble(~x, ~y, ~name, \n                           0,    100,   \"손흥민\",\n                           9.78, 67.94, \"이승우\",\n                           9.5,  56.84, \"윤영선\",\n                           7.64, 38.94, \"김영권\")\n\nfirst_goal_ani <- first_ball_df %>% \n  ggplot() +\n    annotate_pitch() +\n    theme_pitch() +\n    coord_flip() +\n    xlim(-10, 51) +\n    ylim(-15, 101) +\n    labs(title=\"한국과 독일 월드컵 예선\", \n         subtitle=\"김영권 첫번째골(90+2)\") +\n    geom_label(data = first_player_df, aes(x = x, y = y, label = name), family = \"NanumGothic\") +\n    theme(legend.position = \"none\",\n          text = element_text(family = \"NanumGothic\")) +\n    ggimage::geom_emoji(\n        aes(x = x, \n            y = y),\n        image = \"26bd\", size = 0.035) +\n    transition_states(\n        time,\n        transition_length = 0.5,\n        state_length = 0.0001,\n        wrap = FALSE) +\n    ease_aes(\"linear\")\n\nanimate(first_goal_ani, nframes = 24, renderer = gifski_renderer(\"assets/images/first_goal.gif\"))"},{"path":"case-worldcup.html","id":"russia-2018-worldcup-germany-player-second","chapter":"14 .  러시아 월드컵","heading":"14.3.2 손흥민 두번째 골","text":"두번째 손흥민의 골은 주세종이 독일 골키퍼로부터 공을 가로채서 이를 손흥민에 연결하고 손흥민이 빠른 주력을 이용하여 골대까지 전력질주하여 골을 넣은 경우라, 공뿐만 아니라 선수의 움직임도 함께 애니메이션화하여 시각화한다.러시아 월드컵 독일전 두번째 골","code":"\n# 2. 두번째 골 데이터 ------\n\nsecond_ball_df <- tribble(~x, ~y, ~time,\n                          69.28, 15.52, 1,\n                          75.89, 22.89, 2,\n                          24.28, 62.89, 3,\n                          24.28, 62.89, 4,\n                          2.85, 60.52,  5,\n                          -1.07, 46.31, 6)\n\nsohn_movement_df <- tribble(~x, ~y, ~time, ~name,\n                            35.28, 62.89, 1, \"손흥민\",\n                            35.28, 62.89, 2, \"손흥민\",\n                            35.28, 62.89, 3, \"손흥민\",\n                            24.28, 62.89, 4, \"손흥민\",\n                             2.85, 60.52, 5, \"손흥민\",\n                             2.85, 60.52, 6, \"손흥민\")\n\njoo_movement_df <- tribble(~x, ~y, ~time, ~name,\n                           69.28, 15.52, 1, \"주세종\",\n                           75.89, 22.89, 2, \"주세종\",\n                           75.89, 22.89, 3, \"주세종\",\n                           75.89, 22.89, 4, \"주세종\",\n                           75.89, 22.89, 5, \"주세종\",\n                           75.89, 22.89, 6, \"주세종\")\n\nsecond_goal_ani <- second_ball_df %>% \n  ggplot() +\n    annotate_pitch() +\n    theme_pitch() +\n    coord_flip() +\n    xlim(-10, 101) +\n    ylim(-15, 101) +\n    labs(title=\"한국과 독일 월드컵 예선\", \n         subtitle=\"손흥민 두번째골(90+6)\") +\n    theme(legend.position = \"none\") +\n    geom_label(data = joo_movement_df, aes(x = x, y = y, label = name)) +\n    geom_label(data = sohn_movement_df, aes(x = x, y = y, label = name)) +\n    theme(text = element_text(family = \"NanumGothic\")) +\n    ggimage::geom_emoji(\n        aes(x = x, \n            y = y),\n        image = \"26bd\", size = 0.035) +\n    transition_states(\n        time,\n        transition_length = 0.5,\n        state_length = 0.0001,\n        wrap = FALSE) +\n    # transition_manual(frames = time)\n    ease_aes(\"quadratic-out\")\n\nanimate(second_goal_ani, nframes = 24, renderer = gifski_renderer(\"assets/images/second_goal.gif\"))"},{"path":"case-corona.html","id":"case-corona","chapter":"15 .  코로나19","heading":"15 .  코로나19","text":"장기간 코로나19로 인해 가장 약한 사슬인 자영업자를 중심으로 경제적인 어려움을 호소하고 있지만 방역당국의 가장 중요한 국정목표는 코로나19로부터 국민은 안전하게 지키는 것도 사실이다. 이런 점에서 2019년 12월 중국 후베이성 우한시에서 촉발된 코로나19 범유행이 2020년 전세계를 강타했고 대한민국을 비롯한 세계 각국을 혼돈의 도가니로 몰아넣었다.정말 2020년 대한민국은 다른 국가와 비교하여 바이러스로부터 국민은 안전하게 지켰을까?이런 질문에 답을 하기 위해서 2015년부터 2020년까지 대한민국과 비교되는 주요 국가를 추려 월별 사망자수를 뽑아 비교해보자. 이를 위해서 먼저 데이터는 World Mortality Dataset 을 다운로드 받아 데이터를 전처리한 후에 시각화를 통해 해답을 구해보자.전세계 코로나19 월별 사망자 데이터를 가져와서 우리나라와 비교가 되는 국가를 추려 ggplot 시각화를 위해 데이터 전처리 작업을 수행하고 작은 창(facet)에 2015년부터 2020년 1~12월까지 시각화한다. 코로나19로 인한 국가별 사망자 비교를 위해 색상을 달리하여 강조한다.대한민국을 비롯한 주요 선진국 총 9 개국은 인구가 다르기 때문에 절대적인 사망자수만 놓고 보게되면 아무래도 인구가 많은 나라가 사망자수가 많다. 월별 절대 사망자수를 놓고 봐도 그 이전 5년과 확연히 다른 사망자 패턴 즉 유난히 2020년 사망자가 많이 늘어난 것은 코로나19로 인한 국가적인 방역실패로 단정지을 수 있다. 특히 2020년 상반기 코로나19로 인한 사망자 급증과 도시 봉쇄 등 언론을 통해 널리 알려진 국제뉴스 진원지가 영국, 이탈리아, 프랑스, 미국, 브라질이라는 것은 우연이 아니다.국가별로 절대 인구규모가 다르기 때문에 y-축을 상대척도로 바꿔 국가내 사망자수가 코로나19의 영향을 받았는지 확대해서 면밀히 비교하도록 시각화한다.국가별 인구상황을 고려하여 코로나19 방역능력을 비교할 수 있도록 각 국가별 사망자수를 상대적으로 시각화한 그래프를 살펴봐도 유사한 결론에 도달할 수 있다. 선진국으로 불리는 영국, 스웨덴, 프랑스, 이탈리아는 2020년 봄 코로나19로 인한 사망자 증가를 자체 방역역량으로 극복을 하였으나 브라질은 여전히 예전 수준을 회복하지 못한 것이 확인된다.\n대한민국, 독일, 일본은 코로나19로 인해 특별히 사망자가 더 늘어났다는 점이 눈에 띄지는 않고 있다. 이를 통해서 사회 전반적으로 다른 여타 선진국과 비교하여 사망자 증가로 이어지지 않은 것은 K방역의 저력을 보여준 사례로 보여진다.","code":"\nlibrary(tidyverse)\nlibrary(lubridate)\nlibrary(reactable)\n\nmortality_raw <- read_csv(\"https://raw.githubusercontent.com/akarlinsky/world_mortality/main/world_mortality.csv\") \n\nmortality_tbl <- mortality_raw %>% \n  filter(country_name %in% c(\"South Korea\", \"Japan\", \"Brazil\", \"United Kingdom\", \"France\", \"Germany\", \"United States\", \"Italy\", \"Sweden\")) %>% \n  filter(! year %in% c(2021, 2022) )\n\n## 국가별로 달리되어 있는 월별, 주별 사망자 데이터를 월별로 통합\nmortality_monthly_tbl <- mortality_tbl %>% \n  filter(time_unit == \"monthly\") %>% \n  mutate(year_mon = lubridate::ymd(glue::glue(\"{year}-{time}-01\"))) %>% \n  select(국가 = country_name, 연도 = year_mon, 사망자 = deaths)\n\nmortality_weekly_tbl <- mortality_tbl %>% \n  # Week --> Date\n  mutate(base_year = lubridate::ymd(glue::glue(\"{year}-01-01\"))) %>% \n  filter(time_unit == \"weekly\") %>% \n  mutate(date = base_year + lubridate::weeks(time -1)) %>% \n  # Date --> Year + Month\n  mutate(month = month(date)) %>% \n  group_by(country_name, year, month) %>% \n  summarise(사망자 = sum(deaths)) %>% \n  ungroup() %>% \n  # Year + Month --> 연도 \n  mutate(year_mon = lubridate::ymd(glue::glue(\"{year}-{month}-01\"))) %>% \n  select(국가 = country_name, 연도 = year_mon, 사망자 = 사망자)\n\ndeaths_tbl <- bind_rows(mortality_monthly_tbl, mortality_weekly_tbl)  %>% \n  mutate(year = year(연도),\n         month = month(연도)) %>% \n  mutate(is_2020 = if_else(year == 2020, \"2020년\", \"2015~2019년\")) %>% \n  mutate(국가명 = case_when(국가 == \"Brazil\" ~ \"브라질\",\n                            국가 == \"France\" ~ \"프랑스\",\n                            국가 == \"Germany\" ~ \"독일\",\n                           국가 == \"Italy\" ~ \"이탈리아\",\n                           국가 == \"Japan\" ~ \"일본\",\n                           국가 == \"South Korea\" ~ \"대한민국\",\n                           국가 == \"Sweden\" ~ \"스웨덴\",\n                           국가 == \"United Kingdom\" ~ \"영국\",\n                           국가 == \"United States\" ~ \"미국\"))\n\ndeaths_tbl %>% \n  ggplot(aes(x = as.integer(month), y=사망자, group = year, color = is_2020)) +\n    geom_line() +\n    facet_wrap(~국가명, scales = \"fixed\") +\n    scale_x_continuous(limits = c(1,12), breaks = c(2,4,6,8,10)) +\n    scale_y_continuous(labels = scales::comma) +\n    scale_color_manual(values = c(\"gray50\", \"red\")) +\n    theme_minimal(base_family = \"NanumGothic\") +\n    labs(x=\"\", y=\"사망자\", title = \"코로나19로 인한 주요국가 월별 사망자수 비교\",\n         subtitle = \"2015년부터 2020년 월별 사망자수\",\n         color = \"\") +\n    theme(legend.position = \"top\")\ndeaths_tbl %>% \n  ggplot(aes(x = as.integer(month), y=사망자, group = year, color = is_2020)) +\n    geom_line() +\n    facet_wrap(~국가명, scales = \"free_y\") +\n    scale_x_continuous(limits = c(1,12), breaks = c(2,4,6,8,10)) +\n    scale_y_continuous(labels = scales::comma) +\n    scale_color_manual(values = c(\"gray50\", \"red\")) +\n    theme_minimal(base_family = \"NanumGothic\") +\n    labs(x=\"\", y=\"사망자\", title = \"코로나19로 인한 주요국가 월별 사망자수 비교\",\n         subtitle = \"2015년부터 2020년 월별 사망자수\",\n         color = \"\") +\n    theme(legend.position = \"top\")"},{"path":"references-1.html","id":"references-1","chapter":"References","heading":"References","text":"GitHub 저장소 : clauswilke/dataviz","code":""}]
